# Bringing it all together: Tamagotchi
Video•
. Duration: 29 minutes
29 min

URL: https://www.coursera.org/learn/uol-introduction-to-programming-1/lecture/uE1tV/bringing-it-all-together-tamagotchi

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key Okay, so in this video what we're going to do is we're going to take all the things that you've learned so far in this topic and we're going to bring them together to create a kind of game. And we're going to model that game on the old mid-90's game called Tamagotchi. Now, if you're familiar with what Tamagotchi was, it was a game where you had a little creature and it was on a hardware device. And you could tend to that creature everyday, and as you tended to it, it would grow. But if you neglected the creature, it would gradually shrink and waver, and eventually die. And so the aim of the game was just to get your Tamagotchi to grow as much as possible. So I've got some example code for us to get going with. So far, you can see that all I've done is create a tamagotchi object. I've also translated the coordinate space so that 0, 0 is the center of the canvas, rather than it being the top left-hand corner. And that's going to help us in our drawing later on. So the first thing I'm going to do is I'm going to add two methods to the tamagotchi object. I'm going to add a method called setup and a method called draw. So I just declare them as properties, and put the function right into the object like so. So there's the setup method, and here is the draw method. Now, in case you're wondering, I'm allowed to do this because they are properties of a tamagotchi object. So they're not going to interfere with the setup function here, or the draw function here. Okay, so I want to see if these functions are working, and I need to work out where to call them from as well. So I'm going to put a simple console.log in each one. So we'll just put setup here. And draw here, okay? So I'm going to call setup unsurprisingly from the setup function in my sketch. So I do that by typing tamagotchi.setup. And I'm going to call draw from the draw function in my sketch. So I do tamagotchi.draw. Now, if this is working what I should expect to see is setup printed once to the console, and then draw just printed lots and lots of times. So let's give it a try. Okay, let's open the console and have a look. Okay, so I can see that draw is working, and if I scroll right to the top, I can see setup is working as well. Okay, so the next thing to do is to make some points to draw the Tamagotchi. Now, what I want to make for the Tamagotchi is a kind of wobbly round shape that kind of looks like a little bit lifelike. So in order to do that what I'm going to do is I'm going to make an array of points. So I'm going to, first of all, make a property for my points, and I'm going to call it points. And that's going to be an array. Now, in the setup function, I'm going to use a for loop to populate that array with some p five vector objects. So I can comment out this now. And I can go for var i = 0, i is less than, I think I'm going to have 36 points, and i++. Okay, I'm going to make a local variable here, and I'm going to use the createVector function to create those p five vectors. And for the moment I'll just put in 0, 0. And we'll deal with proper coordinates shortly. Okay, and finally I am going to add them to points. So I say this.points.push(v). And I'll just get rid of that console log for draw. And if I go back, I'll just refresh this one more time, and we now look at our tamagotchi object, we can see we've got an array with 36 vector objects in it. So everything is working as we expect so far. Right, now let's deal with the points. So initially what I want to do is I just want to make a series of points that go round in a circle. So I need to do a few things. First of all, I need to set this vector. Rather than setting it at 0, 0, I'm going to set it at 0, I think, 200. So that's going to make the points, instead of being right in the center of the screen, it's going to make it offset towards the bottom of the screen. The next thing I'm going to do is I'm going to rotate the vector. So this is what's going to spread the points all around the circle, and I need to work out what the angle to rotate it is. So let's make a variable. I'm going to make it up here, and I'm going to call it incr for increment. And if you remember, rotate takes radians, and there are 2 pi worth of radians that equal a full rotation. So if I've got 36 points and I want to work out what the perfect distance is to space out those points, I take 2 pi and I divide by 36. And that will give me the precise angle that I need between each of those points. So I've got a special built-in variable in p five called PI. I multiply it by 2, and I divide everything by 36, and that gives me the value for incr. So I will just comment this sort of this code runs. And we can actually, let's console log that incr value so that we can see what it is. Okay, so we can see that one increment is 0.17 with lots of other numbers at the end. Okay, so finally what we need to do is we need to use this variable to work out how much to rotate each vector by. So the way we do this is, I'll make another local variable, I'll call it a for angle, and that will be equal to incr times i. So the first angle will be 0, the second angle will be 0.17, the next one will be 0.3 something, I'll let you work out the rest. So finally what we do Is we rotate the vector by the angle a. So if I look back at my sketch now, I'll just refresh this. And we look at our points array, we'll see that now all the coordinates are different, and that's because they've been rotated around to form a circle. So the next thing to do is to actually draw these points. So in the draw method, I'm going to traverse my points array. So I'm going to use a for loop. I need to add the length property here. So this will make sure that we traverse just the right number of iterations for the number of points that we have. And for each point, just for the moment, I'm going to draw an ellipse, and I'm going to draw it this.points at the index i.x, I will split this up cause this code will get long. At the index y, and we'll make the ellipse just five pixels. And let's just make sure that our fill is set to white. Okay let's see what we've got. And there you can see my points nicely spread around in a circle. Now, the next stage is to get a smooth line, rather than a series of points. So instead of using an ellipse, I'm going to type here, begin shape, and I'm going to type here, end shape. And I'm going to convert this into a vertex. And for a vertex, I don't need to specify a size, so I can get rid of that last number. And now you can see, we've basically got a circle. And you might be thinking, well, why didn't you just draw an ellipse? And the reason is that I actually want to convert this now into a kind of wobbly shape. So we're going to distort it, and I wouldn't have been able to do that with just using the ellipse command. Okay, so, to distort the shape we're going to do a couple of things. We're going to change these vectors from vectors that have this fixed size, into what I would call a unit vector. That's a vector whose length is exactly one. So I'm going to say, create a vector. Instead of naught to 100, I'm going to create a vector going from zero to one there. And also, I'm going to add a new property. I'm going to call this property size, and I'm going to make size 200. So now what I'm going to do, when I draw the points, I'm going to have to multiply them out by the size in order to draw the shape properly. So if I look at the moment, you'll see that. Perhaps you can just about see there's a tiny white dot in the middle of the screen, because my vectors are so small, they're only one pixel long, so everything is kind of appearing in the same place. So I now need to multiply those vectors, and I'll get my shape back again. So what I'm going to do is, I'm going to make this a local variable to deal with this, and I'm going to make it equal to this point i. So this will just allow us to type things a little bit easier. So I will say v.x, v.y. Okay, the next thing I'm going to do is I'm going to use that static method from the p5 vector object. So I'm going to go p5vector.mult, and I'm going to multiply this points i by this.size. So that's going to produce a new vector object to do the drawing, and it's going to be the unit vector multiplied by the size. So each vector now is going to be 200 pixels long. And if we look back, we can see we've now got our circle back, but I can adjust the size of the circle by saying tamagotchi.size. Let's make it half the size, for example, or I could make it smaller again. And so you can see how that works. So that's going to be quite useful for us in a bit. Okay, now I said I needed to make a wobbly shape. So how am I going to do that? Well, instead of just creating unit vectors, I'm now going to create vectors that have a slight randomness to the size. So instead of putting one here, I'm going to say random. And I think I'm going to go random between 0.75 and 1. And now you can see, we have a wobbly shape. Because each of those vectors is a slightly different length. The final thing, I don't really like how this shape is got this kind of jagged edge, because we're drawing straight lines between the points. So instead of doing that, I am going to use the curve vertex. And that will get rid of the jaggedness, so let's have a look. There we go. Now we've got a nice, smooth wobbly shape. Okay, so the next thing to do is to get our Tamagotchi to shrink and to grow depending on user interaction. So I'm going to make two methods for this, I'm going to make one called grow. And one called shrink. So in order to make the Tamagotchi shrink, all I need to do is change the value of its size property. I could say here, this.size *= 0.99. Now, that means that every time that method is run, the size is going to be 99% of what it was before. So each time, it's going to be that 1% smaller. So we could run this in draw. So we could have the Tamagotchi starts at, say, size 200. And unless you're doing anything else, it's just going to shrink, and shrink, and shrink. So let's try that, tamagochi.shrink. And there you can it shrinking, now that shrinking is a little bit fast, so I'm going to do a couple of things. I am going to say, instead of just multiplying it by 0.99, I'm going to say a random amount between 1, which is no shrinkage at all, and 0.9995, which is a much smaller amount of shrinkage. So now we should see almost imperceptably shrinking over time. So, let's see. So you have to watch it very carefully there, but it is starting to shrink. The other thing I want to do is I want to make sure that size can't go below a certain number, because I don't want it to shrink into complete nothingness. So I'm going to say, this.size equals the maximum, either 30 or this.size. And that will constrain its value, so it will stop it from going below 30. Okay, so that's the shrinking dealt with. I also want to be able to grow the tamagotchi. So the way I would do this is by dragging the mouse. And so if I drag the mouse, the tamagotchi will get bigger. So if I go to the mouseDragged function, I can call the tamagotchi.grow method. And so for the grow method I can use, roughly, the same approach. I can say this.size. Well, let's use an obvious version, first of all, *= 1.01. Now I'm going to need to make my tamagotchi a bit smaller so that I can make it grow in the first place, so we'll make it size 100. And if I go back here and I start dragging my mouse, where you can see, it's growing, but that's a little bit too easy for my tamagotchi game. So, again, I'm going use the same approach. I'm going to say this.size *= a random amount somewhere between 1 and 1.0005. Well, let's make it a little bit better than that so that it's possible to make it grow. So let's see if that works for us now. Well, I think that growth is a little bit imperceptible, so I think I'm going to add a bit more. Let's say it was 1.005. Let's try that. Yeah, that feels good now because I can make it grow, but it's still not too easy for me to play. Okay, the final thing is to make sure that this tamagotchi doesn't get too big. So I say this.size equals the minimum amount. Either, let's say, 220 or this.size, so that's the maximum size a tamagotchi can reach, 220. Okay, so we've got the basic mechanics of our tamagotchi working, but I want it to look more life-like, so I'm going to add some extra features now. So the first thing I'm going to do is to add some eyes, and to do that I'm going to change the fill color from white to a darker color, so I'm going to choose purple. There's our purple tamagotchi and the next thing I'm going to do is to draw the eyes in white. So I'm going to set the fill color back to white here and I'm going to draw an ellipse. And I'm going to make this ellipse, I'm going to make its position just slightly offset from the center and I'm going to use the size of the property to adjust that position so that has the tamagotchi grows, the eye is in the right place. So I'm going to say that the ellipse position, its x position is this.size times, well, let's try 10% of the size, times 0.1. The y position is just going to be zero and, again, now for the size of the eyeball, I'm going to use the stock size. So as the tamagotchi grows, it's eyes get bigger. So this.size also times, well, let's try 0.1 as well. We probably will need to do some adjustments here. And so let's have a look of what we've got. Okay, there's one eye. I'm going to add the second eye now. So that was the right side, to do the left eye all I need to do is I need to make the x value negative so that when this side for the positive, now it's going to go this side for the negative. And there we have two eyes, so that looks, actually, pretty good to me. We try and make the tamagotchi get bigger and, you can see, as it gets bigger the eyes are proportionately adjusting with it. I'm going to just start with a bigger tamagotchi now because it will help us to see what we're doing. So I'm going to just set its starting size to 200. Okay, the next thing I'm going to do is to draw some pupils. So for those I need a fill color of black and I'm going to put an ellipse. In fact, I'm going to just copy this code. And I'll make these much smaller, though. I'll make them. Let's say they're 5% of the total size, and we should have some little black dots inside the eyeballs. Okay, there we go. The thing is that those, now I want these to be offset. So I want these eyes not to be bang in the center because our tamagotchi looks a little bit startled there. So I'm going to do this in a particular way and you'll see why in a moment. So I'm going to create a local variable and it's going to be a P5 vector object. And let's say that it's going to be 0, 1, so this is going to offset the eyes, the pupils downwards and I'm going to then multiply it by the amount of pixels I want to offset it. So let's say this.size * 0.0. That's for 10%. Let's see how that works. And we're going to add it here into the x and the y. So, we add here plus v.x, and here v.y. And we'll do the same for the other eyeball, v.x, and v.y. And, hopefully, we should see that the tamagothci's pupils are now slightly offset downwards. Okay, I think I've made that amount too small, so let's try half a percent, Still too small for my liking. Let's try 1%. I think I might go one more time. I think I'm going to go as far 2%. Let's see what we get. Okay, there we go. So our tamagotchi's now got these pupils that are looking down slightly. Okay, so the reason I’ve done this approach is, what I want is for the eyeballs to actually follow my mouse around as I move it around. And this will make a kind of life-like character for our tamagotchi. So I need to do a few things inside mouseDragged to do this. So first of all I'm going to create a vector. I'll make a local variable and we will create a vector. I'm going to initialize it with mouseX and mouseY. Now, if we think about our coordinate space. We want these coordinate spaces to match. And at the moment, mouseX and mouseY, well, that's 0, 0 in the top left-hand corner. But we know because we translated our coordinate space, 0, 0 should be in the middle of the screen. And this position should be minus width divided by 2, minus height divided by 2. So if you think about this, if we want these coordinate systems to match, all I need to do is minus width divided by 2 from mouseX and minus height divided by 2 from mouseY. And that will make the two coordinate systems match. So that's what I'm going to do here, I'm going to minus width divided by 2 here. And minus height divided by 2, here. And now v will represent where the mouse is in the coordinate space that we're actually drawing in. The next thing I'm going to do is I'm actually going to normalize this vector. Now if you remember, what normalized does, is it turns this vector from a vector that can have any length into a unit vector. That means its length will be exactly one. And the final thing I'm going to do is I'm going to pass it, My apologies, I realize I've done this in the wrong place. I've done this in mouseDragged, but I meant to do it in draw. So the next thing I'm going to do is I'm going to cut these two commands from mouseDragged, and I'm going to just pop them into draw. And now the next thing I'm going to do is I'm going to pass this vector as an argument into the draw method. And in the draw method, I am going to add an argument called eyeDirection. So now this vector, v, which is a normalized version of where the mouse is, becomes eyeDirection here. And the final stage is, instead of creating a vector, v, here, I can just make v equal to eyeDirection. And so, if my mouse is pointing up, this will make the pupils point up. If it's down, it will make them down, and so on. So let's see the effect, so here is my mouse and you can see now that the eyeballs are following the mouse, making a kind of life-like effect. Okay, I got one more thing I want to do. So at the moment, where my tamagotchi grows, it's not very interesting. And so I want to make some kind of motion when I interact with it. And what I'm going to do is I'm going to rotate all of the coordinates by a random amount when the grow function is called. And I think that that will make a nice effect. So I'm going to make a local variable called rot. And I don't want my rotation to be big, because it's going to happen lots of times. It's got more like a kind of shuttering effect. So I'm going to just say that it could be anything between minus 0.01 and plus 0.01. Got a typo there. The next thing I'm going to do is I'm going to iterate through all my points. So I'm going to use a for loop. And it's this.points .length. And finally, I actually need to do the rotation. So, I say this.points, at the index i, and we use the rotate method. And I use my variable called rot. And now we should see our tamagotchi kind of shuffle about as they grow. So let's give this a go. So there you can see it shuffling about because it's growing. And as it shrinks, nothing happens. Move the eyeballs, and there you can see it growing again. So, now it's your turn, maybe you want to adapt this tamagotchi further. Maybe you want to add more different reactions for different type of things. Maybe something for key strokes, or different movements of the mouse. I'll leave that to you, see what you can do. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 9.1 Methods Lesson 9.2 p5 vector - static and non-static methods Video: Video Exploring a p5 object: Vector . Duration: 18 minutes 18 min Video: Video Bringing it all together: Tamagotchi . Duration: 29 minutes 29 min Graded Assignment: p5 vector: static and non-static methods . Duration: 15 minutes 15 min
# Being creative with nested iteration
Videoâ€¢
. Duration: 10 minutes
10 min

URL: https://www.coursera.org/learn/uol-introduction-to-programming-1/lecture/TH3Xr/being-creative-with-nested-iteration

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key So, now that you have a basic understanding of nested iteration, let's explore some creative ideas. So, we've got some code now that should look familiar to you. I'm using some nested iteration to draw a 20 by 20 grid of ellipses. So, the first thing that I could try and do is use somehow these i and j indexes to affect the ellipse. So, what I'm going to do is I'm going to use one of them. I think I'll use i to change the size of the ellipse. So, i is the one that's controlling the columns. So, what I wanted to try and do, is make the ellipses start off very small and gradually get bigger. So, what I could quite easily do is just instead of putting 30 for the width and the heights, I could just put the value i in here. if we look at the result, now we can see that the ellipses start slow and they gradually get bigger. So, they start at absolute zero. So, maybe we actually want to start a little bit bigger than that. So, we can sort this out with just a little bit more arithmetic. So, for example, I might put the minimum size as five. So, I could go five plus i here and five plus i there. Now, we can see the ellipsis start from a slightly larger size, and gets a little bit larger. Maybe we want them to get much larger, so we want this change to be a little bit more dramatic. So, I could multiply i by a value to do that. So, I could make it i times two and they would get larger at double the rates. Maybe I want them to get wider more than they get taller. So, maybe I would leave this one is times two, but I actually wouldn't multiply this one by anything. Then we can see the i ellipse is gradually become more stretched out. So, these are some ideas you can explore. I might just put this one back for a moment. Now, maybe we want this to go in the other direction. So, if I want this to start off small up here and gradually get larger as we progress down rows, instead of using i here, I could just use j. So, I'll put j in both of these and we get that's going down that way. Or maybe what I want to do is I want to try and use both i and j at the same time somehow. So, now I can do a little bit of guesswork here. I'm not quite so sure what I'm doing, but I'm going to put i instead of this number five in both of these and let's see what happens. So, we get a kind of diagonal progression across here. So, these are things that you can play with and try out for yourself, and see if you can write a different formula that produces a different sorts of pattern. So, what I'm going to do is I'm going to try something else now. But first of all, I'm going to need to create a variable to use because it will just make my coding just that bit easier. So, I'm going to create a variable called r. For the moment, what I'll do is I'll actually say, "R is this formula that we've already wrote." Instead of using this formula here, I'll just put r for both of these values. We can see now that the results is exactly the same because we've just replaced that's a hard coding with a variable. But now, what I want to do is I want to somehow make the circles get bigger, the further they are away from a point. So, I'm going to make my point the center of the screen. If we think about what the center of the screen is, that's width divided by two and height divided by two. I'm going to use the distance function to do this. So, I'm going to measure the distance of each ellipse from the center of the screen. So, I'll go var d, so d for distance, equals, I'm going to use this distance function. If you're not familiar with this function, look it up in the P5 documentation. So, in the distance function, I need to put in two points. I need to put in the center of the screen. So, that's width divided by two. The second argument is for the y of that, of the height divided by two. Now, the second two arguments I need to put in are for the position of each ellipse. If you remember, these two arguments I've highlighted here are for the center of each ellipse. So, I can copy and paste those in there. So, now I've got that distance. That distance, the further you get away from the center of the canvas, the larger d will get. So, that should work for my ellipses here. So, all I'm going to do is instead of using this formula, I'm now going to make r equal to d. You can see that something funny has happened here. The ellipse is just get way too big. So, this pattern doesn't really work anymore. What I need to do is to scale this somehow. So, we'll do it, we'll scale it in a kind of crude way, first of all. I'm going to show you a really good way to scale it. So, here, what I'm going to do is I'm going to just divide it. Let's divide it by 10 and see what we get. So, that looks better. So, now, you can see, this is actually where the center of the canvas is. Then, basically it's a zero and it gradually gets bigger, and the radius of ellipses as we get away from the center of the screen. But if I really want to get control of this, I need to consider what is the longest distance, and then scale my radius by this. So, the longest distance, is the distance from the center of the screen to any one of these corners. So, I think I'm going to use this corner, which is zero zero. So, I'm going to make a variable up here called maxDist. So, that's my maximum distance. After I've created my canvas, I can say, maxDist equals, and I can just use the dist function again to measure this. Since the distance between zero zero, and the center of the screen, which is width divided by two height divided by two. If we're interested in what that value actually is as a number, I could console log it. So, I'll do that. If we look in our console now, so this distance is 565. You might be surprised by that. Maybe you were thinking that it would be 400 because our canvas is 800 pixels by 800 pixels. But remember, the diagonals are longer than just this distance here. Let's get the console closed. So, now we have our maximum distance, what we can do is we can use this to scale our distance that we measure here. So, instead of dividing this by 10, I'm going to divide it by maxDist. Now, what this means is that the maximum value of r is now one, and the minimum value of r is going to be zero. So, by multiplying r by a value, I can set the maximum size precisely for an ellipse. So, I think I want my ellipses to be no bigger than 30. So, I'm going to put r times 30 here. If I save that, you can see now that the ellipses at the furthest point, they're just about getting to fatty and none of them overlap. So, that's a much more controlled way of doing it. So, the next thing I want to do, is instead of having a fixed point, I want this point to be movable with the mouse. So, I set the center of the screen, but instead of using the center of the screen, lets just use mouseX and mouseY. So, I simply just change these values, the mouseX and mouseY. Now, we have something much more dynamic, where I can change the size of the ellipse according to where the mouse is. We call this thing actually a distance field. I'm going to show you one more idea to do with this, and that's to make some striped columns going across our grid of ellipses. So, I'm going to use conditional statements to do this. What I'm going to do is I'm going to try and work out wherever I am on an odd or an even column. So, to do this, I'm going to use an operator that you perhaps don't know yet, and that's the modulo operator. So, I'm going to write my conditional here, and I'm going to see if i modulo two equals zero. What the modulo operator basically does is it divides the number on the left by the number on the right and it sees whether the remainder is zero or something else. In this case, if it's an even number, if I divide it by two, will then there will be no remainder, so that means it's an even column. Otherwise, there'll be remainder, so the value will be higher, and therefore, it's an odd column. So, if it's an even column, we want the color to be white. If it's an odd column, which will be the else, we want it to be purple. So now, you can see we have whites and purple columns alternating. So, something for you to try is to see if you can get your head around this and work out if you can make some kind of checkerboard pattern. How could you adapt that code? You might want to also play with some other things, maybe some random variation in there or making colors respond to the distance field. Have a go with it, and see what you can produce. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 6.1 Advanced work with arrays Lesson 6.2: Nested Iteration for drawing patterns Video: Video Nested iteration to draw grids . Duration: 13 minutes 13 min Practice Assignment: Nested iteration to draw grids . Duration: 15 minutes 15 min Video: Video Being creative with nested iteration . Duration: 10 minutes 10 min Reading: Reading Code it from scratch: Warhol soup . Duration: 1 hour 1h Discussion Prompt: Warhol soup . Duration: 20 minutes 20 min Lesson 6.3: More work with arrays Lesson 6.4: Debugging techniques
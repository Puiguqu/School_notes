# Code philosophy: testing
Videoâ€¢
. Duration: 6 minutes
6 min

URL: https://www.coursera.org/learn/uol-introduction-to-programming-1/lecture/s3LLB/code-philosophy-testing

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key This topic's code philosophy, is about testing the programs that you write, in sharing that they work the way you expect and are ready for use by real people. So far, on this course, we've spent a lot of time talking about debugging and the skills required to make sure your code is free from bugs. It's a vital skill for programmers to learn. Beyond debugging, there is a whole extra discipline required to be a world-class coder and part of an effective software team. That process is software testing. We aren't going to get into the formal process of testing in this module, but it's important to understand a little about how the process works and how it affects the way we write our code and plan our software. Software testing is the process of making sure that our code is not only bug-free but also fit for the purpose that it was designed for. That often is not as simple as just clicking the button on brackets and ensuring your code doesn't crash. Code is long and complex. Very often, your part of it will only be a very small mechanism within a much larger machine. Your code may run but does it work with the rest of the code base and not break the other pieces of the system. Let's take an extreme, but important example. Boeing 787 Dreamliner aircraft which took to the skies in 2009 required around 14 million lines of code, an enormous engineering challenge. The consequences of failure will be hugely serious. For that reason, software developers working on safety critical systems such as those used by airliners, would write at an absolute maximum 30 lines of code a day. To put that into perspective, 30 lines is about the same as a single sleuth puzzle template. It will take an individual about 1200 years to write 14 million lines of code at that pace. Therefore, any individual contribution will be relatively small to the total amount. Everyone's code needs to work together and the system has to be fully tested before being used in a commissioned aircraft. While the stakes may be much lower with your programs, for now attenuate, there are some important principles you can make use of. Let's go right back down to Earth and the other end of the complexity scale. Here's a small example that shows why debugging might not always be enough. Look at this snippet of code. We could run this code plenty of times and it would work just fine. But what happens when the random number generated is exactly 100? Take a second to pause and have a look at the code. A random value of 100 would execute the else block in this piece of code. It may be that that was the intended action, but let's assume it wasn't and correctly the code should have used X less than or equal to 100 in the first statement. We could have debug this code many times and never seen a problem. But if we release this to the public, the error would occur quite frequently with hundreds or thousands of users. We sometimes refer to these conditions as edge cases. Something we hadn't considered when we write the code, and in the most part, won't cause problems with our software, but sometimes will crop up. You may think of testing as a process that is considered when the software is complete. You have written some code and you then need to make sure it works okay. On the contrary, good software is designed and a test plan is created that reflects that design. But how can we know that the software we have written is fit for purpose, if we really don't know yet what that purpose is? The design process can tell us this. An effective start point for writing software is requirements gathering. This includes determining exactly what functionality of the software needs to implement to be considered successful. What hardware will it require to run and who will be using it when we're done. The code you write in this module, never really need a detailed plan or requirements, but it is good practice to be thinking this way from the outset of our programming career and always having an eye on what it means for a piece of code to meet the requirements you set. In the next topic, we're going to look in more detail at these curious function things we keep talking about. You're going to start writing your own functions. Not just draw and setup, but ones that implement functionality, you need for your program. With this new knowledge, will also come the ability to divide up your code into small, manageable and reusable chunks. By dividing up your code like this, it is much easier to test and verify that things are working the way you expect them to. There is an advanced technique called unit testing, that exploit these properties of functions. Finally, I couldn't talk to you about testing and not mention the area of computer science that I'm most interested in. By and large, you aren't going to be the user. So, if you are testing your code yourself, you aren't really exploring how it works when you hand it over to the real world users of the system. We call this process user testing and it's a big part of human-computer interaction. Let me give you an example, I'm sure most of you have been locked out of a sleep puzzle at some point. That part of the system was added in after students here at Goldsmiths had played sleuth. Through testing it with our students, we noticed that some were getting a bit too obsessed trying to solve a single puzzle. By creating the lock mechanism, we were able to limit this behavior and ensure that students take a little time out and think about the problem in the abstract. We only saw these negative behaviors when we gave it to real users of the system. The Beta testers we used, who had a bit of coding experience, didn't exhibit the same patterns. To conclude. This topics code philosophy is when debugging ends, testing begins. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 6.5 Code philosophy Video: Video Code philosophy: testing . Duration: 6 minutes 6 min Lesson 6.6 Game project 5 - Multiple interactables Lesson 6.7 Sleuth: Start of Pro stage - Lesson 6.5 Code philosophy Video: Video Code philosophy: testing . Duration: 6 minutes 6 min ## Lesson 6.5 Code philosophy - Video: Video Code philosophy: testing . Duration: 6 minutes 6 min - Lesson 6.6 Game project 5 - Multiple interactables ## Lesson 6.6 Game project 5 - Multiple interactables - Lesson 6.7 Sleuth: Start of Pro stage ## Lesson 6.7 Sleuth: Start of Pro stage - CM1005 Introduction to Programming I - Code philosophy: testing # Code philosophy: testing You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key
# Returning early and the call stack
Videoâ€¢
. Duration: 10 minutes
10 min

URL: https://www.coursera.org/learn/uol-introduction-to-programming-1/lecture/yIZo3/returning-early-and-the-call-stack

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key In this video, we're going to have a look in more detail of what happens in terms of program flow when you call a function. To do this we're going to use the Chrome debugger. Now, I'm using the debugger in Chrome, but you could use it in Safari or Firefox for that matter. So, the sketch I've got you can download it as well, it should look familiar to you. It's just a version of the sketch from the last video. We've got the drawFlower function and that's being called from the draw function and the output we see is this flower. So, what I'm going to do is I'm going to show you first of all how we find the debugger. So, I have the console open which should be familiar to you, and I'm going to go to this menu and I'm going to look for sources. So, I click on the "Sources" tab, and then I click on "Sketch.js". In this tab you can see the code that you're running. So, I'm just going to make this window a little bigger. What I can do now, is I can click in this column here, where I want the program to stop. This is called a break point. So, I'm going to click on this first line of the draw function. You can see now my program has actually stopped at that point, that's what this blue line represents. Now, in this bar here, I have a bunch of options for things I can do. This one on the far left means I could just resume running the program, and it would resume running, but it would stop again at this line because the breakpoint is still there. So, I'll try that one, and you can see it has just drawn another frame and it stopped exactly at the same point. But a more interesting one is this one. This one allows me to step through the different function calls. So, if I do this one you can see I'm stepping through, and when I get to the end, we'll go a bit into the p5.js library. But, in essence, it will go back to the beginning of the draw a loop, so I can keep doing that. The next button is the one that's really important for this video, this one is called the step into. What this allows us to do, is it allows us to follow where the code goes when a function gets called. So here I have the execution line is on drawFlower, and I'm going to press this button to step into that function. So, we can see but when we call drawFlower, the execution line goes into the code for drawFlower. Now, I'll step through these. You can see all this code being executed. But the interesting point is when we get to the end, where does this execution line go next. Well, if I press it it just goes back to the line off the drawFlower was called. So, that's how the flow of a function call works. Let's adapt to our code a little bit and do a bit of an experiment. So, what I'm going to do now is, I'm going to make another function, and I'm going to call this drawPetals. So, I'm going to draw the petals of the function. What I'm going to do is, I'm going to cut and paste the code that draws the petals, which is this bit into that function. Where we did draw the petals, I'll now call the function drawPetals. So, we've changed our program a little bit. We now have a function call from within another function. So, let's see what happens when we follow the code flow. So, I am going to just refresh this page, and go back to my sketch.js. I'll have a quick look and check, and I can see that my updated code is there. So, let's first of all step into drawFlower. You can see we start working for the drawFlower function, and then we get to drawPetals. What I'm going to do now is step into drawPetals. Then, we go through the drawPetals code, and you can see them being drawn there. When I get to the end of drawPetals, can you guess where I go? I go back to the line after the bit that call drawPetals, and now I'm going to step through that code. Can you guess where I'll go now? I go back to the line after drawFlower of this code, and I step for reverse and that's the end of running one loop of the code. I'm just going to do it again, because I want to show you one extra thing. So, I'll press the "Continue" button and we'll start again. I'm going to get to the drawFlower parts, and I'll just make this window a little bit larger, so we can see this. On the left down here, I have something called the Call Stack. At the moment, the only thing that we kind of understand in the Call Stack is there is the draw function, we can see draw here. But watch what happens when I step into drawFlower. So, now we can see draw and then drawFlower. What this means is that, first of all, draw was called and draw called draw flowers. So, it's showing you these series of calls. If I carry on through there and get to drawPetals and stepping to that. You can see our Call Stacks gotten bigger again, because now we have draw, drawFlower, and drawPetals. So, you can see how the Call Stack represents the function calls in terms of which function called which other function. Sometimes we might not want to continue the running the code in a function, we might want to stop running it early. For that we have a special keyword, and that keyword is called return. So, I'm going to show you how to use that, now. I have a second example here. So, I'm going to load that example two. You can download this from the platform as well. I will run this code. Let's have a look at what it does. So, we have a game character here, which I've just taken from the game projects. We have a number of lives for the game character as well. Now, I can make the lives go up and down by pressing the "A" and the "S" key. So, I can't, let's try again. Yes. So, if I press "S" they go up, and if I press "A" they go down and eventually I get to zero lives. Now, what I want is I want to implement some game mechanic where the character disappears when we get to zero lives. To do this, I'm going to return early from a function. So, if we look at our code, we have a function to draw the game character. This function is called from the draw function. So, so far everything is as we would expect. What I want to do is I want to write a conditional statement that returns early from the game character function if there are zero lives. So, I'm going to type it here at the beginning of dual game character function. I'm going to say if, and we have a global variable for lives. So, I can say "If lives is less than one", so that will cover any negative numbers as well. "If lives is less than one at this point we just return". So, what that will mean is that when this function gets called, the line of execution will go through this conditional statement, and if lives is less than one it will just quit running this function here and it will go back up to the next line of code there. So, let's try it. So, we've got three lives at the moment, I'm going to make the lives go down. You can see the game character has now disappeared. Let's have a quick look in the debugger to understand how this is working in terms of code flow. So, I'm going to go to sources, I'm going to select sketch.js. I'll put a breakpoint again have this called to background. So, if I step over that, and I'm going to step into drawGameChar. Here, we are. Here is our conditional statements. So, if I hover over this, we can see lives is zero. So, zero is definitely less than one. So, we should go into that block of code. Here, we hit the "return" keyword, and if I step over that you'll see but we didn't run any of the other code we just returned back to the next line of code after the function call. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 7.1 Functions Video: Video User defined functions . Duration: 9 minutes 9 min Video: Video Returning early and the call stack . Duration: 10 minutes 10 min Practice Assignment: Functions . Duration: 15 minutes 15 min Reading: Reading Code it from scratch: Lights on! . Duration: 1 hour 30 minutes 1h 30m Discussion Prompt: Lights on! . Duration: 20 minutes 20 min Lesson 7.2 Function input and output Lesson 7.3 Variables and scope Lesson 7.4 Debugging techniques
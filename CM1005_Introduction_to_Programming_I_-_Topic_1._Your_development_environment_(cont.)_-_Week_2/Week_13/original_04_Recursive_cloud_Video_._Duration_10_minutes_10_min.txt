# Recursive cloud
Videoâ€¢
. Duration: 10 minutes
10 min

URL: https://www.coursera.org/learn/uol-introduction-to-programming-1/lecture/KI9Jj/recursive-cloud

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key Now, I probably shouldn't show you this next bit as it's an advanced technique and it's slightly risky, but it's so much fun that I couldn't resist. So, you can actually call a function from within itself. This technique is called recursion. Now, I imagine that sounds a little bit confusing. So, an easier example to understand recursion is Russian dolls, Matryoshka. So, with each Russian doll, you open up the Russian doll and inside is an identical copy, but slightly smaller. Then, you open up that copy and inside is another copy, but slightly smaller. This could almost go on forever. Well, obviously, eventually the dolls get too small and you have to stop. So, that's a recursive structure. Another example of recursion that's really famous is the Droste effect. So, Droste was a brand of cocoa, and on the label, famously, it featured an image of a woman holding the same box of Droste cocoa, which had an image of the same woman holding a smaller box of the Droste cocoa, which featured a label which had the same woman holding a box of Droste cocoa, and so on, and so on, and so on. So, it went on forever. This is also an image of me in a Opera which featured some recursion. You can see the recursion happening, stretching back behind me. Okay. So, let's have a look at how recursion works within code. I've got an example here which you can download from the platform. If you look at the code, you can see that I've created a function called recurse. At the moment, it's not recursive, but it's being called from the setup function. We've got three arguments. We've got the x position, the y position, and we've got an argument for scale. If you run the code, you can see at the moment it just draws a simple ellipse. So, I'm going to do a couple of things, and they won't really make sense until I've completed the stage. So, just bear with me. I'm going to type a conditional statement. I'm going to say, if scale is less than five, then return. Now, you'll see why this is important in a moment. The next stage I'm going to do is I'm actually going to do the recursive stage. I'm going to call the function recurse from within recurse. So, I type recurse, and in here I'm going to pass x, y, and this is a really important part, I'm not just going to pass scale, I'm going to pass scale times 0.75. That means that when the function gets called again, the value of scale will be slightly smaller. If we think about how this works, when we run this function a second time, recurse will get called again. When it gets called again, scale will be slightly smaller, and it will keep calling forever and ever and scale will keep getting smaller. Apart from we have this conditional statement, and when scale is less than five, we return. We don't call recurse again. This means that all the functions down the call stack will gradually return and so will end up back at the set up function. So, here's the question: can you work out how many times the function recurse is going to be called? Okay. Well, if I look at my code, I can see now the effects of this. I have lots of ellipses, each one getting smaller and smaller and smaller, and the smallest one will be just probably a tiny bit bigger than five pixels in diameter. So, if we think about this in terms of the code flow, the first time we called it, scale was at 100. Well, then we scaled that argument by 0.75. So, scale will then be 75. Now, the math starts getting tricky. So, we have the scale again times 0.75, so it'll be a bit smaller, a bit smaller, a bit smaller, and eventually, it gets to some number that's less than five and the whole thing bails out. So, you could imagine it's a bit like your Russian dolls getting smaller and smaller and smaller, but eventually you get to the point where the doll is just too small and you can't physically fit another doll inside, and so the process stops. So, the reason I said that recursive functions are dangerous is if I was to comment out this conditional statement, this would create an infinite set of function calls and that would crash your program. Let's start now making this a little bit more interesting. What I want to do is I want to shift the ellipses in terms of their x position. So, instead of just calling recurse with x here, I'm going to add a value. I'm going to add the value scale, but I'm going to divide it by two. So, what I'm doing is I'm gradually shifting the ellipses across, but because I'm using scale, that amount of shift will get smaller and smaller and smaller. So, let's see what the effect is. So, now you can see, I've shifted the circles and they gradually get closer together as they get smaller. Now, what I want to do is I'm going to try and do the same, but in the opposite direction. I'm going to minus scale here. Now, you might think that this will just draw double the amounts of circles, but that's not quite how it works with recursion. Because if you follow this through, each time we call recurse, we call two more recurse functions, and those two more calls call two more functions each. So, we get an exponential growth in the number of function calls. This is another reason why we have to be very careful with recursion because the amounts of code being run mounts up very quickly. So, I'm going to save this, and you should see that in the output. So, you can see now we're drawing loads of those circles. So, we're starting to get towards a really nice and interesting pattern. What I'm going to do next is I'm going to play around with the y position. So, in terms of the y position, what I think I want to do is to add a random offset. So, I'm going to use the random function, and I'm going to say that that offset is somewhere between minus scale divided by two, and scale divided by two. So, I'm using scales so that the offset is proportional to the size of the circle that we're drawing, and that creates a really pleasing pattern. So, I'm adding this to both of my function calls here. Let's save that and see what the result is. So, now you can see we have this cloudy pattern and we get these chains of movement here. That's because we're only shifting proportional to the scale with the circles. So, as the circles get smaller, they get shifted less, and less, and less. So, finally, what I'm going to do is add a bit of random color to this sketch so that we can get a really nice pattern out of it. So, finally, what I'm going to do is I'm going to add some random colors so that we can see more detail in our pattern. So, I'm going to do this within the function before I draw the ellipse. So, I'm going to put a fill command here, and I'll just say that I'll choose a random value between 0 and 255 for the red, random between 0 and 255 for the green, and the same for the blue. Then, I'm going add an alpha value and I'm going to make this quite low because there's lots of circles overlapping. So, I think I'll make it 50. Finally, I'm going to turn off the stroke because we don't want to draw the outlines of the circle. So, instead of putting stroke here, I'll put no stroke. Semicolon. Great. Now, you can see we get this really nice cloudy effects. Because I'm using random, if I refresh the sketch, I'll see its slightly different effect each time, but always in a cloud pattern. So, have a go yourself with these recursive functions, have a play around and see what patterns you can produce. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 7.1 Functions Lesson 7.2 Function input and output Video: Video Function arguments . Duration: 8 minutes 8 min Video: Video Recursive cloud . Duration: 10 minutes 10 min Video: Video Returning values from functions . Duration: 21 minutes 21 min Practice Assignment: Function I/O . Duration: 15 minutes 15 min Lesson 7.3 Variables and scope Lesson 7.4 Debugging techniques
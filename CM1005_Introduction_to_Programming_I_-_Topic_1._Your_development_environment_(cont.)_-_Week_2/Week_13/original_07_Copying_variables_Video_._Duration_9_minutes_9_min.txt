# Copying variables
Videoâ€¢
. Duration: 9 minutes
9 min

URL: https://www.coursera.org/learn/uol-introduction-to-programming-1/lecture/kiVWz/copying-variables

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key Let's take a look at what happens when you make one variable equal to another variable. There is a bit more going on behind the scenes that you may not have considered yet. Hopefully, by now, you've written lots of lines of code that look like this one; making one variable equal to another. But have you thought about what happens to var1 when we change the value of var2? Does it get updated to the value 100 or does it values stay the same as it did before var2 was reassigned? The answer is, it depends on what var1 was to begin with. In JavaScript, if our variables store simple types, numbers, strings, or booleans, then the value is copied from one variable to the other and any effect on the second variable will not affect the first. In this example, I have created two variables. The first, var1, is assigned to the number 23, the second is assigned to var1. So to begin with, they are both 23. I then multiply var2 by 10, then the program is outputting the two variables to the console. You can see that var1's value is 23, var2's value is 230. This is also true, if I pass a simple type as an argument to a function. In this example, I have again created two variables; var1 and var2. This time, var1 is a string and var2 is equal to the return value of a function called change string, which is taking var1 as a parameter. The change string function is just changing the value of any string given to it to "goodbye Earth" and then returning it. The return value is a different string which is saved to var2 but you will notice that var1 is still the same value and hasn't been changed. The situation isn't the same with complex variable types. In other words, objects. This includes arrays, which under the hood of JavaScript are a special type of object. Let's look at these with a longer example. Okay. So now, we've looked at copying variables with very simple types such as booleans, strings, and numbers. We're now going to look at it with more complex ones. So, objects. In JavaScript, when we're copying those simple types, we call that passing by value because we are literally taking that whole value and saving it in another variable. When we're doing it with more complex types, JavaScript isn't copying over the whole object, it's just copying a reference to it, so it's called passing by reference. So, if you had a massive great big objects with thousands of properties in it or an array with millions of elements, then JavaScript isn't making copies of it in memory. So, we're going to look now at a very simple example that explains this concept. If I show you this sketch which you can download right next to this video, it just draws a simple rectangle which is created with an object, rect1, it draws it to the canvas and it's in a nice purple color. Let's add in another object, we'll call it rect2 that we're just going to copy the values out of rect1 to it. So, if we create a new variable var rect2. Then if we say here that rect2 equals rect1 and save that. I've actually put in already a little bit of drawing code that is only going to draw rectangle two, if the mouse is been pressed. So, it's going to toggle between showing rectangle two and not showing rectangle two. So, if we save the sketch, and if I click on rectangle one now, we'll see the rectangle two is drawn over it in this nice teal color. If I put in a little bit of transparency for that as well, we'll be able to see. So, definitely are overlaid one over top of the other. So, when I'm copying those values from rect1 to rect2, it seems like rect2 is the same as rect1. But say I wanted to change the width of rect2. Before I draw it, I will probably do something like this. So, rect2.size is equal to 400. So, if I do that and save it, we see that rect1, the purple rectangle is also being increased in size to 400 pixels. If I click on it, the rectangle for rect2 is also being drawn at that same size. So, whatever change I make to rectangle two is going to affect rectangle one. Conversely, if I also change rect1.x to be 200, I save that, rect2 also is updated. The two variables are actually pointing to the same object in memory, it's just a reference to that object rather than the whole object being stored in memory against correct one and rect2. Just to make this absolutely crystal clear, let's have a look in the inspector. Let's pull up these two values. So, let's have a look at rect1 and rect2. So, these are the two objects, rect1 we have a size of 400 and x of 200 and a y of 200, and rect2 is exactly the same. If I was to update rect1.y, make that equal to 200. Then, rect2 will also update as well. So, we can see this both in the console and through the graphical output. All right. Now you're thinking; what happens if I do want to pass by value with these objects, how can I go about doing it? Well, with simple objects, there is a trick that you can do. So, rather than saying rect2 is equal to rect1, rect2 is equal to an object and the object has an x-coordinate which is equal to rect1.x, y which is equal to rect1.y and a size which is equal to rect1.size. So, if I save and run that, we'll go back to our original object and we can draw by for them out in the same location. Let's now update rect2.x to be equal to 200, we save that, and you can see that rect2 is now being drawn slightly offset from rectangle one. We've managed to change one value without changing the other one. This works because rect1.x is a simple type, it's a number. So, if I set the x property of rect2 to be equal to that simple type, we then passing by value again. Just to prove that this same properties work with arrays as well, we'll just create a very quick global variable called myArray and make that equal to 1, 2, 3. Then, if we also create myArray2, for now, we'll just make that equal to the empty array, and then in our setup function, if I say myArray2 is equal to myArray, then we have passed by reference. So, myArray2 will be equal to the reference to that object, not the actual object itself or the actual array itself. Then if I do myArray2 at location zero is equal to say 100, and then console.log, so we'll just print this out to the console just as a quick example just to show you how it works. So, myArray and console.log myArray2 save that. Whoops we've got little mistake in there, why we need the inspector anyway. So, let's just see what we've done. Unexpected taken apron brackets on line five. Whoops I've forgotten the equal sign there, there we go. You can see that both myArray and myArray2, the first element is now equal to 100. So, whatever you change you make to myArray2 is also going to equal to myArray1. In the last couple of videos we have looked at scope, and we've also looked at this idea of copying variables. In the next video, we're going to look at some of the common problems that you may encounter when applying these techniques. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 7.1 Functions Lesson 7.2 Function input and output Lesson 7.3 Variables and scope Video: Video Scope - global and local with var . Duration: 11 minutes 11 min Video: Video Copying variables . Duration: 9 minutes 9 min Practice Assignment: Scope and copying variables . Duration: 15 minutes 15 min Lesson 7.4 Debugging techniques
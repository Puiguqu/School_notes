# Binary search trees
Videoâ€¢
. Duration: 14 minutes
14 min

URL: https://www.coursera.org/learn/uol-discrete-mathematics/lecture/XYlri/binary-search-trees

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key In this lecture, we will discuss binary search trees. We will begun by defining a binary search tree. Then we will look at how a binary search tree is used in practice. Then we will work through two examples that show how a binary search tree can be built to hold a number of records, and the relation between them, as well as the heights of these trees. Then we will examine the binary search tree algorithm. Finally, we will look at an example of how this binary search algorithm works in practice. Previously, we talked about binary trees in general. In this lecture, we'll be looking at binary search trees, which are a type of binary tree. Let's begun by defining what a binary search tree is. A binary search tree is a binary tree in which the vertices are labeled with items so that a label of a vertex is greater than the labels of all vertices in the left subtree of this vertex, and is less than the labels of all vertices in the right subtree of this vertex. For example, the following tree is a binary search tree as every label of a vertex is greater than the labels of all vertices in the left sub tree of this vertex, and is less than the labels of all vertices in the right subtree of this vertex. Well, let's imagine a scenario in which we want to store a modifiable collection in a computer's memory, and be able to search, insert, or remove elements from the collection in an efficient way. Binary search tree can be used to solve these kind of problems. In this example, we will build a binary search tree that is able to store 15 records. We also want to find the depth or height of this tree. This is the maximum number of comparison to be made to find any record in this binary search tree. In this case, the minimum is equal to one, whereas the maximum is equal to 15. To find the root element, we add the minimum which is one to the maximum which is 15 divided by 2 and take the floor of the results. The root in this case is eight. Anything that is less than eight, which is one to seven, goes on the left sub tree, whereas anything bigger or larger than eight, which is nine to 15, goes on the right subtree. We repeat the same process by dividing the sum of the minimum and the maximum on each side and take the floor of the result to find the vertices on the next level. The vertices on level one are then four and 12. The same process is repeated, that is put the records with values less than the value of the found record on the left subtree, and the larger values on the right subtree of the record. For each side, add the minimum to the maximum, divide it by two and take the floor of the results. This process is repeated till all the 15 records are stored. Now that all the records are stored, we can add external nodes on the graph as green rectangles. These external records can be used to store any additional records. Let's now talk about how to find the height of a binary search tree. Let N be the number of records to store in a binary search tree. There are two methods you can use to find the height of a binary tree. The first method is as follow: The height h has to satisfy the following formula; 2_h minus 1 is strictly less than N plus 1, and N plus 1 is less than or equal to 2_h. The second method, the height h of the tree is equal to the ceiling of log to the base 2 of N plus 1. Both of these formula are equivalent as can be shown. The first formula is equivalent to the following, which is equivalent to the height is equal to the ceiling of log of the base 2 of N plus 1. For example, if the number of record is 15 in the binary search tree seen in previous slide, the height of this tree is four as shown using both methods. In the second example, we want to be able to store 4,000 records in a binary search tree. The aim is to find the first three level of this binary tree and workout the depth or height of this binary tree. Let's now build a binary search tree which can store 4,000 records. The records are from one to 4,000. We only want to build the first three level of this binary search tree. First, we want to find the root of the tree. So we take the minimum plus the maximum, we divide it by two and take the floor. Therefore, the root of this tree is 2,000. We then anything that is less than 2,000 goes on the left subtree, anything that is bigger than 2,000 goes on the right subtree, and we repeat the same process. The minimum here is one and the maximum is 1,999. We take 1 plus 1,999 divided by 2 which is 1,000. Then the next record in here is a 1,000. Here again, the maximum is 4,000 whereas the minimum is 2,001. We add max to the minimum, we divide by two, and we find 3,000, and 3,000 is the next record on the right side. We repeat the same process. Anything that is less than 1,000, goes on the left side. So the minimum here is one and the maximum is 999. So on the right sub tree, anything that is bigger than 1,000, goes on the right sub tree. So from 1,001-1,999. Similarly, for the record 3,000. Anything that is less than 3,000, will go on the left sub-tree whereas everything that is bigger than 3,000, will go on the right sub tree. So if we take the minimum here and the maximum and we add them and we divide by two then take the floor, then we will find 500. So 500 records will go in this vertex. Similarly, if we add 1,001 plus 1,999 divided by two and take the floor, the next record will be 1,500. Similarly, if we take the minimum which is 2,001 plus the maximum which is 2,999 divided by two and take the floor, we will find next record there will be 2,500. Finally under left sub tree of 3,000, the minimum is 3,001 whereas the maximum is 4,000. We take the minimum plus the maximum we divide by two and take the floor of the result, then we get 3,500, then the next record is 3,500. As you can see, we build three level of the binary search tree as has been asked. The first level is level 0. The second level is level one which stores 1,000 and 3,000, and the third level which is level two which stores 500, 1,500, 2,500 and 3,500. Now let's try to find the height of a binary search tree which can store 4,000 records. We can either use the method, the first method that we've seen before, which is two to the power of h minus one is less than one plus n, which is Less than or equal to two to the power of h, where n is the number for record and h is the height of the tree. So if we use that, we can do here and replace n by 4,000 and we can replace h by 12. Therefore, using this method will give us the height of this tree is equal to 12. Or we can use the second method that we have seen before, where h or height is the ceiling of log of base two of n plus one, where n is the number of records. So if we use this formula and we substitute n by 4,000 and take log base two of 4,001 then take the ceiling of the result, will find the result is 12. So using both methods, the height of this tree is equal to 12. Now let's take a look at the binary search algorithm. Suppose we have a list of numbers in ascending order, and we want to search for a particular value in this list. The binary search algorithm starts by comparing the search element to the middle term of the list. The list is then split into two smaller sub lists of the same size, where one of these smaller lists has one less term than the other. The search, continue by restricting the search to the appropriate sub-list, based on the comparison of the search element and the middle term of the list. Let's consider this practical problem. Searching for the value 21 in this list. You can see that this list is in ascending order. Which is required for the binary search algorithm to hold. First split the list, which has 16 terms into two smaller sub-lists, with eight term on each. Then compare 21 to the largest term of the first list. Because 12 is less than 21, the for 21 will be restricted to the second sub-list. , this second sub-list is split into two smaller sub-lists, of four terms each. The first sub-list has 14, 15, 17, and 18 whereas the second sub-list has 20, 21, 22, and 24. Because 18 is less than 21, the search is now restricted to the second of the sub-lists. , the second sub-list is split into two lists. The first one has got 20 and 21, whereas the second has got 22 and 24. The search is then restricted to the first sub-list, which contains 21 and 20. , this list is split into two sub-lists of one term each. The first list contains 20. Whereas the second one contains 21. As 20 is less than 21, the search is then restricted to the second list. Now the search has been narrowed down to one term and 21 is located as the 14th term in the original list. In this lecture, we looked at the definition and uses of binary search trees. We start by defining a binary search tree. We then show how binary search tree, is used in practice. We also showed via an example, how to build a binary search tree, and the relationship between the number of stored records and the height of the binary tree ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 8.2 Rooted trees and binary search trees. Video: Video Rooted trees . Duration: 8 minutes 8 min Reading: Reading Rooted trees . Duration: 15 minutes 15 min Practice Assignment: Rooted trees . Duration: 20 minutes 20 min Video: Video Binary search trees . Duration: 14 minutes 14 min Reading: Reading Binary search trees . Duration: 15 minutes 15 min Practice Assignment: Binary search trees . Duration: 20 minutes 20 min Reading: Reading Rooted and binary search trees . Duration: 2 hours 10 minutes 2h 10m Discussion Prompt: Binary and linear searches . Duration: 10 minutes 10 min Peer-graded Assignment: Trees assignment . Duration: 1 hour 1h Review Your Peers: Trees assignment Reading: Reading Topic 8 summary . Duration: 15 minutes 15 min 8.3 Extra resources
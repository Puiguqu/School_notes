# Webinar on Boolean algebra
Videoâ€¢
. Duration: 1 hour 26 minutes
1h 26m

URL: https://www.coursera.org/learn/uol-discrete-mathematics/lecture/mmDtB/webinar-on-boolean-algebra

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key Today's session will be about a Boolean algebra. I'll just give you a summary of what you need to know from this topic. This is what I will be talking about: some applications of Boolean algebra, some operators of Boolean algebra, logic gates and logic networks, and also we'll talk about the simplification of circuits using Karnaugh maps that we have done and that you have also in the midterm assessment. Application of Boolean algebra is in computer circuit analysis. Boolean algebra, again, is the basic block for designing transistors, which are the basic elements in building processors. So Boolean algebra is used to simplify and build logical circuits and we will look at that in a bit by the end for the lesson. The two-valued Boolean algebra. The most well known form of Boolean algebra is the two-valued system, where there are only two variables, which is zero and one. I repeat, zero stands for false or low and one stands for true or high input, and we'll look at that in a minute. The operators that are used is the plus for the or operator and the product dot for the and operator. If you see in propositional logic, we use the and and or but in Boolean algebra we used dots for the and, and we use plus for the or. It is used to describe and design digital circuits. That's why we study Boolean algebra. Let's look at operations of Boolean algebra. Boolean algebra is based on three fundamental operations: the and which is the logical product, we'll write x. y, which stands for x and y, and in sets we do x intersection y, and in propositional logic we do x and y. Or is x plus y, which stands for the or again, if you still remember in propositional logic. In sets we use the union and in propositional logic we use the or. The again, the inverter or the not gate. The inverter is x prime, we use this notation, x prime or x bar or just not x. We will be using this notation for Boolean algebra, we will be using x prime. When parentheses are not used, these operator have the following order: not has the highest priority followed by and, then followed by or. This is just a summary of what we've done then we can go and do some examples. Let's now look at the logical product which is the and. x. y or sometimes we don't put the dot, we just put x y, it stands for the and. This it's a truth table, so 0.0 is 0, 0 and 1 is 0, and 1 and 0 is 0, and 1 and 1 is 0. Then this is the or operator which we use the plus, so x plus y. If we have two operators, x and y, 0 plus 0 is 0, 0 plus 1 is 1, 1 plus 0 is 1, and 1 plus 1 is 1. Is the same as the or that we've done in propositional logic. Then there is the inverter, which is the not. We use x prime, so you got x here and you get x prime here, which is not x. If x is 0, x prime is 1, if x is 1, x prime is 0. This is the three main operations that are used in Boolean algebra. Now, we will look at some postulates or some laws of Boolean algebra that we'll use later on to simplify Boolean expressions. We looked at Huntington defines six axioms that we've looked, if you looked at the video, that must be satisfied by any Boolean algebra. The closure with respect to the operator, so it means like any result of any logical operation be belongs to this set, has to be either zero or one. Means the output of any logical operation, the value of its outputs is either zero or one. It can be only one of those two values. There is the identity, the identity which means x plus 0 is equal to x, means x or false in propositional logic is equal to x if you remember. Here in Boolean algebra we do x plus 0 is equal to x, means it doesn't change anything and x.1 is equal to x. This is the identity and we can use these laws to simplify Boolean expressions. The next one is commutativity. What commutativity is, is just changing the order does not affect the results. Here, x plus y is the same thing, as y plus x. If I change x to y and y to x, I won't change the value and the same thing for x for the logical product. X.y is equal to y.x. So changing the order of x and y does not change the value of the expression and that's what commutativity is. Then there is distributivity, which is similar to what we've done in propositional logic. We just use here dot, dot and plus instead of the OR and the AND. X.y plus z is the same, is equal to x.y plus x.z. The same thing, we say that dot dot is distributive over the plus and the same thing, x plus y.z is x plus y.x plus z. We say that the plus is distributive over the logical product. The other one is the compliment law or the complement axiom. X plus x prime is always one. If x is zero, x prime is one, so 0 plus 1 is always 1. If x is one, x prime is zero, we still have 1 plus 0, always one of them is true. We have always x plus x prime is always 1, and if you remember in propositional logic, we said p OR p prime is always true, one stands for true. Similarly for the logical product, which is dot dot, x.x prime, is equal to 0. If you remember in propositional logic, p and not p is always false. Here in Boolean algebra, x.not x, which is x prime, is always equal to 0. Then the other one is distinct. There must exist at least two element, x and y with x different from y. The distinct elements, they must exist at least two distinct element and in this case we only have zero and one and zero is different from one. Then this is true for two valued Boolean algebra that we are looking at. I'm just go through this postulate one by one, then we can use them later on. By using these postulates that I'm talking about here, by using them, we can build other theorems, we can establish other basic laws that we will be using. We can do idempotent law, x plus x is equal to x doesn't change anything. X and x is equal to x, doesn't change anything, this is called idempotent laws. The other one is a tautology, x plus 1 is always 1, x AND 0 is always 0 The other one is the involution law, which is, if you imply the negation twice, you don't change anything. So, x prime pi is always equal to x. Then the other one is associative law. x plus y plus z. Associativity deals with the groupings. If I group x and y first, if I did this operation first, x plus y, and I take the result and I do plus z, that doesn't change the value. If I group y and z first, then take the result of y plus z, then add it to x, so the value does not change. Associativity deals with grouping. It means the order of grouping element does not affect the results. It's the same thing for the dot dot. The logical product, x.y.z. If I group x and y first, and I found this result of x.y, then I take this result and z, then it doesn't affect the result. If I change the grouping to be, I group y and z first get the results, then this result.x, so it does not change the results. Associativity deals with just the order of grouping the element of the expression. If the grouping does not affect the result, then the relation is said to be associative relation. Then, there is the absorption law, which is x plus x.y is always equal to x, and x.x plus y is always equal to x. This is called absorption law. Then, there is the uniqueness of the complement. For example, if x plus y is equal to 1, and y.x is equal to 0, then x must be equal to y prime. It's like uniqueness of the complement. X can be only equal to y prime and can be different, if it satisfies these two properties here, then x must be equal to y prime. Then there is the inversion law, which is like the prime of 0 is 1 and prime of 1 is 0, just not 0 is 1, and not 1 is 0. Now, let's look at other theorems. One is called De Morgan's law. We've done De Morgan's law in propositional logic, we've done De Morgan's law in sex and we can now do De Morgan's law in Boolean algebra, which is the same. The complement of the products is equal to the sum of the complement. The complement of x.y, Is equal to the compliment of x plus the complement of y. If you remember what we've done in propositional logic, we've done the complement of p and q, is equal to the complement of p, or the complement of q. It's exactly the same thing here. We just dot dot is the AND and a plus is the OR. That is the first De Morgan's law of Boolean algebra. If we look at this, if we want to check that this is true, we just do the truth table. This is not x and y, and it will give us 1,1,1,0, and this is not x. The bar doesn't show here, but there is a bar over x and there is a bar over y. Not x, plus not y, is 1,1,1,0. As you can see, those two columns are the same. This means that those two logical expressions are exactly the same. We'll have the same value. As you can see, they are true at the same time and they are false at the same time. Therefore, the complement of x.y is equal to the complement of x plus the complement of y. Now, if I take you to the complement of a sum, so now the compliment of x plus y is equal to the complement of x dot the complement of y. All we have done here, put dot, replace it by plus, and replace the plus by dot, and we will get the second De Morgan's law. If we want to show that is true, we can do, again, the truth table for those two. Here, the first green column corresponds to the complement of x plus y. If you can see, this is 1, 0, 0, 0, and this is the complement of x and the complement of y, which is the complement of x dot the complement of y. You can see that is 1, 0, 0, 0. Again, those two columns are the same, therefore, those two expressions are exactly the same, or they are equivalent, or they have the same value. Now, that we looked at the Huntington's Postulates, we looked at some basic law, Boolean algebra, then we looked at De Morgan's law. Now, let's see to prove that plus is distributive over the dots. Which is, we need to show that x plus y and z is the same as x plus y.x plus z. One way of proving this is just to build the truth table. This is the truth table for x plus y.z. It gives me all those values. If you check, you can find all those values. Then I do the truth table for x plus y.x plus z, and I get those values. As you can see, there those two columns again are the same. Therefore, x plus y.z is the same, or its equivalent to x plus y.x plus z. Those two logical expressions are equivalent. If this is true, then we say that the plus is distributive over the logical product. Now, again, one thing that we looked at is the principle of duality. Starting from a Boolean relation, we can build another equivalent Boolean relation by using the following. Changing each plus to dot, we change plus to dot, and changing the dot to plus, then changing zero to one, and one to zero. For example, by distributivity, we have this. A plus B.C, by distributivity, is the same as A plus B.A plus C. If I change this plus to dot, and I change this dot to plus, I'll get A.B plus C. I come here to the second part of the expression, and I change this plus to dot, I'll have AB, and I change this dot in here to plus and I have plus, and I come here and I change this plus here to dot, and I have A plus C. If this is true, by using the principle of duality, we can deduce that this is always true. All what we have done is whenever there is plus, we put a dot, whenever there is a dot, we put plus in this expression. Let's now look at another expression. Let's consider this expression here. I have a.1.0 plus a bar is equal to 0. Assume that this is true, which is. Then by doing the principle of duality of this expression e1, we change this dot to plus, we change this one to zero, we change this dot to plus, we change this zero to one, we change this plus here to dot, and we leave that, and we change this zero to one. If this is true for e1, then the dual of e1 is always true. The same thing for e2, the expression e2. We have a plus a bar dot b is equal to a plus b. Now, let's write the dual expression of e2. We change plus to dot, we have a dot. Then we leave a bar as it is and we change the dot here to plus. Then we came here and we change this plus to dot. If e2 is true, then the dual of e2 is true as well. This is what we call the dual principle. Let me just explain it to you here. For example, if I have, let's say a plus b and one. Let's say this y and here. Let's say this is equal to zero for example. If this is true, then by leaving a as it is, changing this plus here to dot, leaving b changes this dot to plus and changing this one to zero and changing this to one. If this is true, then its dual must be true as well. All we're doing is changing the OR to plus, the OR to AND, and the AND to OR, and zero to one and ones to zero to get the next expression. That's what we call the dual expression. Why we are doing all this is we want to prove that something is true. We want to prove that two boolean expressions are true. There are four ways of proving that two things are equivalent or two boolean expressions or two boolean revelations are equivalent. The first one is called the perfect induction. It just build the truth table. Look at those two columns of both expressions. If they are the same, straightway you deduce that those two expressions are the same. If they differ even in one combination input, and they have different value then those two expressions are not equivalent. The other one is by applying all those Huntington postulate, all those theorem including De Morgan's law and everything, then you can go from one expression and arrive to another expression. One is we use all those laws of boolean algebra. The other one is called the principle of duality. We've just seen. If you have an expression is true, then by interchanging AND's to plus, plus to AND's, and 0's to 1's and 1's to zero might give you what you're looking for. The other one is contradiction. You assume that the hypothesis is false then prove that the conclusion is false as well. That's the four ways of proving that two Boolean expressions are the same, but we will look at a few of them. Let's consider the ops of approving the absorption law. The absorption law is that x plus x and y is equal to x. Here is x in the truth table. So 0,0,1,1 for x, and if we do the truth table for x plus x plus y, we can see that it also equal to 0,0,1,1. Now, this is the perfect induction. Using the truth table, we can show that the column of x is the same as the column of x plus x and y Therefore, we can say that x is equal to x plus x and y, which is the absorption law that we've looked at, or we can use the laws that we've looked at before to show that x is equal to x plus x plus 1. First one is using the truth table. Second one is using the laws of Boolean algebra. We start by x plus x plus y. I can replace x by x and 1 because we already know that x and 1 is equal to x, that's the identity. That way, you can do the distributive law. I can use distributivity of dot of a plus. It will be x. 1 plus x. I can even from here say that 1 plus y is always equal to 1, or I can use commutativity, change the order. One plus y, just to make it y plus 1. Our next step is unnecessary at this time. From here, you can jump to here. I know that y plus 1 is equal to y, which is x plus 1 is equal to x, which is the identity that we've looked at. Then I can change this y plus 1 to just 1. This is now is equal to x and 1. I know that x and 1 is the same as the value of x, the identity. Then starting from x plus y, plus x and y, I got to x. Let me just try to explain that one here to you. What I have, we have x plus x and y, and we want to show that is the same as x. We want to show it. First one is to use the truth table that we've looked at. Second one is to use the laws that we've looked at, laws of Boolean algebra. I'll start from x plus x. y. I can substitute this x by just x. 1 plus x. y. All I have done is substitute this x here by x and 1. The next thing is I use distributive law. This is just x. 1 plus y. You can straight away from here without even doing commutativity, we can know that this is just x and one. We can replace this by one, so x and one. We're also by identity law, we know that x and 1 is the same as x. We started from here and we got to x. First we substitute this x by x and 1. Second, we use distributive of dot over plus. Second thing is we know that 1 plus y is always equal to 1. We substitute this by one. Then we got x and one. Again, the identity property or the identity law allows us to say that x and one is always equal to x. That way of proving that two Boolean expressions are the same. What we've done, we looked at laws of Boolean algebra, we looked at how you can prove that two expressions are the same using other truth table, we also looked at how you can prove that two expressions are the same using this laws of Boolean algebra. Excuse me professor, is it possible to prove the absorption term with the duality principle or contradiction? It is, but can we talk about after the session, then I can answer that question. Sure professor. Thank you. Okay. Let's talk now first about Boolean function. A function defines a mapping from one or multiple Boolean inputs to a Boolean value. What does it mean? Let me just do that. You've got, let's say x, y, z, and this is are all Boolean inputs, that's an input, and you've got a function which is called a Boolean function, that takes x, y, z, and gives you out f of x, y, z. This is Boolean input and it gives you an output as a Boolean value, and when I say Boolean value, the output can either be zero or one, okay? That's what Boolean function is. For any input value, we have two to the power of n possible combination, and I think you have seen before, if we have two inputs, x and y, we have two to the power of two different combination, either 0,0, 0,1, 1,0, 1,1, so we have two to the power of two, which is four combinations. If we have n input, then we have two to the power of n possible combinations. Then if we have three inputs, for example, then we have two to the power of three different combinations. This is the truth table, so Boolean function might be given to us just by it's truth table, yeah? In this case, you got x, y, z. If x, y and z are all zero, then the Boolean function returns one. If x is 0, y is 0, and z is one, it returns zero, such as all the combination possible. We are interested in when the Boolean function returns one. Returns one of all the inputs are zero, it returns one where the first input, which is x is zero, the other two inputs, y and z are one. Is also returns ones, or all the three inputs are one. So there are eight different combinations of three inputs, and I think we've seen this input in propositional logic. There is only one way to represent a Boolean function using a truth table, so you can't represent a Boolean function where truth table different way, there is only one way to represent it, and I'll tell you what it means. However, there is a two ways or a number of ways of representing an algebraic expression. If I have x and y, and I have this Boolean function f of x, y here, and I have, for example, 0,0,1,1. I said, let's say here is 0111. If I have only the truth table, this is the only truth table of this function. There is no other truth table. This is the truth table of this function. However, this function f of x, let's say that the truth table of x plus y here and let's do here the truth table of x plus x prime here. So x plus y here will give us 00111 and x plus x prime, it will also give us 0111. Using the truth table, there is only one way of representing the function. However, I can write that f of x, y is equal either x plus y. Or I can write is equal to x plus x prime. It means there are different ways of representing the function using the algebraic form. But using the truth table, there is only one way to represent it, but we can write the expression differently as long as we use the expression that is equivalent to the original one, and that is what algebraic form is. Algebraic form, we can write Boolean expression different way. There are different ways of writing a Boolean expression. [inaudible] Professor. Yes. With the expression the x, shouldn't that be x and y or x and x? With this expression because now is plus, because it's the all. Zero or true is two. I thought that was, y and [inaudible] The end is this, the end is x. Let's say, let's change the color. The end is you get x, y, x, and y. Yeah? Yeah. This is 00 is 00 and 000 and 1 is 0, 1 and 0 is 0 and 1 and 1 is 1. This is the end. Sorry. I thought we were talking about a specific function, not truth table or no truth table. Because always expects that last output. They are sum of products form. This one, we're talking about the sum of products, but all I'm saying is, this function you can represent it using a truth table with just one way. However, we can re-write the function in different ways, and I said the truth table because this expression, x plus y has the same truth values as f of x, y and the same thing as x plus x prime. I can write f of x, y. Can be either x plus y, or can be either x plus x prime. It will give me the same value. Did I ask you a question or? [inaudible] should be true, right? I have a question. X is zero, y, x prime is supposed to be opposite of zero, which is one. One. yeah. Because 0 plus 1 is? One. I'm talking about the Fed's rule on x. Yeah, it should be one. I will do in different one I suppose. Are you all right? No, you're right. You are completely right. What I want to write here is x plus x prime y. Yeah, I miss the y. X plus x prime y. If we do that x plus x prime y, we always get zero here, get one here, one here, and one here, and we get the same value. Does that makes sense with? Yeah sir. Yep. What am trying to say here, you can have a Boolean function by using the truth table. You can have only one overall presentation like here you can only ever present it like this, but I can find the different expression for that Boolean expression, it can be written differently using algebraic form. In this case, this function here f(x), we can either write it as x plus y as a result or we can write f (x,y) can be x plus x prime y. Is this okay? Yes. Yeah. Okay. All right. We've done the most two common standardized form are the sum of products or the product of sum. What we will be using is just the sum of products because it helps us do a lot of simplify expressions. The sum of product is in how to write the function as this is a product X dot product y plus, so this is all products and we add them together, this is called the sum of products. Or you can go the product of sum, which is sum product of sum product another sum, but the well used form is the sum of products that we will be using and we will be using it to simplify Boolean expressions. A Build a sum of products form, it's easier to build a form using the truth table, if I have the two table, I can build the sum of products easily. First, we focus on the values on the truth table that have gotten output of the function one. If an output is ne the input is one, it appears uncomplemented in the expression and I will explain this. If an input is zero, it appears as complemented in the expression. The function F is then expressed as the sum of products of all the terms for which the function is equal to one. Well, let's look at this one for example. Let's look at this function here. We have got x and we have got here f(x, y) and we've got 000011101111. I'm interested in this, I am not interested in this at all, so I'm interested in this one here and one here and one here. The input here for x is zero, here is x prime and the input of Y is one, I leave Y as it is. The input here for X is one so I leave x, the input for Y is zero so the Y prime. Here, the input for X and Y is both one, then I put XY, then all I do is add them together, so f(x,y) now is equal to X prime Y plus XY prime plus XY. That's how I do the sum product from the truth table. It's easier to do the sum product from the truth table. If any of those three is true, then the function is true. Yeah, and thus the function that you will get using this method, that I've just shown you. Okay, now we look at the Exclusive-OR that we looked, which we use the plus inside the circle, which is the Exclusive-OR which is true if the value of X or Y is true, but not both it's only one of them, in another way, if X and Y have different values. This is the truth table that we have done for the X Or. That's the truth table, zero plus X of zero is zero, 0_x of one is one, 1_x_0, is one and 1x01 is zero. We can see that the x_0 is the same as x prime line. That can be now the truth table, all I know is the two table of the x_0. The x_0 I don't know how to work it in terms of end or 0. All I know, the x_0 has got this truth table. Now I can find this truth table, I can build a sum product. This will give me X prime Y. This will give me XY prime and I add them together. That's the Boolean expression for the export. For the imply, this is the Boolean expression for the implies. X implies Y, zero plus zero is one, zero implies one is one, one implies zero is zero, one implies one is one. If look at that, I can see that can be expressed as X prime Y plus X prime plus Y. If we look at this and simplify it, this will be X prime Y prime plus X prime Y plus XY and that can be simplified to X prime plus Y. What we will be looking at in a bit is how to simplify expressions. Now that we know that the x_0 is just this, let's now look the logic gates. This is all we are doing this Boolean algebra is to help us design yeah, logical circuit and minimize the number of logic gate that we will be looking at. Logic gates; A logic gate is defined to be as the basic element of circuits implementing a Boolean operation. The most basic logic circuits are Or and not the gate. All Boolean function can be written in terms of these three functions, or three logic operations And, Or, and Not gate anything else we can write it in terms of this three basic operation. The end gate producers are high output value when the inputs are high. While both inputs are high, then the And gates produces a high input which is one. In another way, one and one is one, otherwise, the And is zero. This is how we did the And gates. It's straight from here master input, X and Y, and that's the rotational presentation of the And gate, and that's it's true table. X and Y, that's the true table zero and zero is zero, zero and one is zero, one and zero is zero, one and one is one. is the [inaudible] write X and Y or sometime we don't write the dot. If dot is missing XY means x.y. Most of the expressions, we simplify it and just omit the dot. Then there is the next gate is the Or gates, which has this notation here. It's not straight from here, but just that it is half the set can from here. Thus notation for the OR gate, the, Or, if one of the inputs is high, the output is high. If one of the inputs is one, then the output is one as well. That's the X plus Y to a table that we've looked at before, we view as before. We just arrived at X plus Y as an output of the Or gate. Then inverter, which is the Not gate, we give me x and you get an x prime, which is the not X. Zero is one, not zero here is one, one is zero here. This is X and this is the truth table for expired or [inaudible] is an inverter, it inverts the signal, if it's zero, becomes one, if it's one becomes zero. We also write either x bar or x prime to represent this. There are other four additional gates which are the result of a combination of the basic gates. I think that is the X Or gates. There is the NAND gates. The NAND gate is an AND gate, but there is this little circle here to say that is a NAND gate. Or NAND gate is an AND gate followed by an inverter. But we'll look at it in a minute. Then there is the NOR gates, which is the OR gate, but with the little circle here to say that it's a NOR gate, not an OR gate. Then there is the XNOR gate. Again is the XOR with a little circle here. Whenever there is little circle here, it stays for the NOR, NAND or XNOR. I think in the video those two were inverted. But I put a note that they were inverted in the videos. Now, let's look at representing De Morgan's laws using the gates. This is the AND gate. I give it x and y. I get x and y. Then after the NOT gates, I get not x and not y. De Morgan's law says that the not of x and y is the same as not of x plus not of y, so this circuit here is the same as this one. If you look here, we're using three gates and here we are using only two gates. You can still see like, if I want to build a circuit, maybe I'll use two, maybe cheaper and take less space than using three gates. The second De Morgan's law. This again is the same as this one. This is the x, y here, x or y and what comes out of here is the negation of x plus y. It's the same thing as if you negate x, you negate y and you do an AND, it's the same. Those two circuits are exact. These two are the same and these two do the same thing when you're trying to build a logical circuit. Now, we know the basic logic gates and we know the truth table of each one of them. Let's try now to build a bigger circuit or a combinational circuit. A combinational circuit or logic network that are called sometimes are combinations of logic gates design to model Boolean functions. A combinational circuit is a circuit that implements a Boolean function. The logic value assigned to the output signal is a Boolean function of the current configuration of the inputs. I'll explain what it means. Given a function or a Boolean function, we can implement all logic circuits representing all the state of the function. Or given a Boolean function, we can build a logical circuit that represents these Boolean functions. For example, intuitively, before we give you the example, we want to minimize the number of gates in order to minimize the cost of the circuit. That's the whole point. Boolean algebra helps us to design and minimize the number of logic gates. If you minimize the number of logic gates to the minimum, you save space to store more gates to do other things. Then you also minimize the cost and you make the circuit faster. Yeah, you built a faster circuit. A Boolean function can be implemented in different ways using circuits. We have already seen that a Boolean function can be expressed in different algebraic forms. Let's look at this function. X plus y prime z. Let's consider this function. F can be represented by this logical network. We find now this function. Here x, here, y, I'll get here y prime. Here it's z. Here y prime and z. Here come in y prime and z and x and an OR gate here, so this will give me x plus y prime and z, so I cannot represent this function by this logical network or the circuit. Given a logic network, we can also work out the Boolean function. We find out the Boolean function. I can build a logical network. If I know the logical network, I can also build the logical circuit. Now, let consider this example. Let's consider we have these inputs: x, y, z, and w. This is a NOR gate. So the negation of x plus y in here comes in here. Then here, there is z coming from here, and this is a NAND gate then I have z and the negation, the complement of x plus y. Then here I have z dot the complement of x plus y, and here, w coming here, then here is a NOR gate then the expression is z dot the complement of x plus y for w. That's the output of the circuit. Giving it x and y, this circuit will output z dot the complement of x plus y plus w. Now, let's look at why we're doing all this? :45 When we want to add binary digits, for example, adding two digits, 1 plus 1, 1 plus 0, which computer do a lot. What the computer they don't know how to add, but they all use those gates to add, the logic gates to add. Let's look at how we add. If I add 0 plus 0, it gives me 0, and what I carry on to the next column is zero. If I add 0 to 1, the result of the sum is 1 and one I carry on to the next is carry out is zero. If I add 1 plus 0 is giving me 1, I carry out is 0. If I have 1 plus 1, the result of 1 plus 1 is 0. The addition in binary number and what we carry on is one. If I look at this sum here, this result of the sum. This represents the xo. If I can put an XOR gate, it will give me the sum. If I look at those values of the carry-out, this represents the AND gate. I can build this to add to a binary digit. By doing this, the sum is an XOR, :18 and what you carry out is an AND gate. This gives you the sum, how you add two binary digits. The result of a sum, you use this XOR gate. The result of what you carry on to the next column is you use this AND gate. However, this is called a half other, by the way. Its limitation is, you only can use it when you add one binary but you can't use it, for example. Let me explain this here. :16 You all know addition of binary numbers, yeah, 1 plus 1 plus 1. Suppose I want to add this, :29 so 1 plus 0 is 0 and I carry on zero. :39 1 plus 1 plus 0 is 0 and I carry on one. :47 1 plus 1 again is 0, and I carried one, and 1 plus 1 is 0 1. :58 If you want to do this operation, you need three inputs, not two inputs. :11 Because the second column here, you have 1 plus 1 plus the 0 that are coming from the previous one, but if it's just a zero, that is fine, but sometime it's one coming from the previous column like in here. We have 1 plus 0, but one coming from previous column. :32 What we actually need is we need a circuit that has three inputs. One input is the x, let's call this x, and this is the y and the y, and one input is the carry-in were coming from the previous column. So you need three inputs. By using half adder, we can do 1 plus 1, that is fine. That would give us zero as the sum and one for the carry-on. We can use a half adder if we just wanted to do one bit adding to another bit, but if we want to do a sequence of bit like 1 plus 10111, for example. That straightaway from here, 1 plus 1 is 0, I carry 1. I need three inputs for this. So this is the disadvantage of having a half adder. You can only add one binary digits. thing is, what can we improve on that? We have something that we call a full adder. Full adder includes a carry-in bit. It has three inputs. You have x and y, and it have some value that we carry in from the previous column. :58 Again, you'll have eight, because now we have three inputs, you have eight combinations. This is the sum and this is what you carry out, and if we look at that, we can see that the sum is x, x or y, x or what you carry in this here, and the carry out we can build, again, using the things that we looked before. We can see that carry-out is x and y plus the carry-in dot x, x or y. That's what's important is the circuit. The circuit is this. Right here is the sum, which is x, x or y, the carry-in here is another x OR then we've got the sum. What comes in here is x, x or y, x or carry-in. Again, for what you carry out, you have carry-in dot x, x or y and here an AND gate, x and y, and here a plus, and if you plus this to this, you'll get what you carry. This is called a half adder. What we thought really is this is we just use the simplification and we call this a full adder and it has three inputs: it has x and it has y and it has carry-in, and it carries out. Here's the sum and there is also an output for the carry-out. We just use a block for the full adder. Full adder are used to add binary operations that are carried out by a computer system. What is full adder? It is a logic gates. Put some logic gate together to do some addition. Actually, all operations are done using logic gates. All operations in a computer are done using zeros and ones. Now that we know how these logic gates are used to build combinational circuits or logical networks, now we want to simplify. We look at ways of simplifying the number of logic gate that we can actually use in a circuit. Every function can be written as a sum-product, but this formalization is not necessarily optimal. It's not optimal and we will have a look at one example to look at that in terms of the number of gates and the depth of the circuit. :04 This is why circuits needs to be simplified. Simplification of the circuit, also called the minimization or optimization, is beneficial in circuit design. Reduce the global cost of circuits by reducing the number of logic gates used might reduce the time of computation. If you have reduced the number of logic gates, you reduce the computation time of the circuit. Also you save space and you allow more circuits to be fitted in the same chip. Let's look at algebraic simplification is based on the use of Boolean algebra. We can either use Boolean algebras law to simplify the circuit, or we can use something that we can call the Karnaugh map that we looked at. I'll get to that. The sum product need to be used as one of the following laws. De Morgan's law, distributive laws, commutative, idempotent laws, you can use all those laws to simplify circuits or absorption law. Let's look at this example. This example was on the video, and I think the last step should be this. I rectified it by a slide if you look at it now. Let's consider this one. We have this Boolean expression and we want to build a circuit for it. That is a lot of NOT gate lots of AND gate, lots of PLUS gates there. But can we simplify this Boolean expression? We can use De Morgan's law and involution law. This will take us to this. Yeah, this is only De Morgan's and involution will take us to x_y plus z prime dot x_z prime plus y_z then we can use distributive law. Then we can write it in this form of the sum product. Then with this, we can use commutative, idempotent, and compliment law we can get to this, x_y_z prime plus x_y_z plus x_z prime. Using the absorption law, we will just get x_y_z plus x_z prime. I'll look how many gates we had before in the original expression. Now what we want this Boolean function to do can be done by just this. These three AND, and one OR, and one NOT gate. Yeah, and this is that simplifying Boolean expression using laws of Boolean algebra that we've looked at. The other thing that is used to simplify Boolean expressions is the Karnaugh map. Our presentation. The Karnaugh map is a graphical representation of Boolean function. It is different from a truth table. It can be used for expression with 2, 3, 4 or 5 variables. Let's look. The column map is shown in an array of cells, and cells differing by only one variables are adjacent. I'll explain to you, what that does mean. Let's look at this function here. Let's look at this function f. It has only two inputs. The Boolean function is 1,0 gives you 1, and 1,1 gives you 1. We write here x prime x, y prime y. If you go from here to here, the only thing that is changing is y. If you go that way, the only thing that is changing is x. That's why we need two consecutive cells, we need only one variable to change. Yeah, and the others are fixed. :58 Having this function, we already know that, :07 x_y prime is 1, x_y is 1. This is the Karnaugh map. We just build in the Karnaugh map for this Boolean function, we are not doing any simplification yet. Let's now go and try to look at this Boolean function. We have got the truth table, but first, we need to find the Karnaugh map for this function. If I look at here, I put here x prime and I put here x. If I have y prime z, the only thing that is changing this way is x. Going down, the only thing that is changing in any column is x. For example, going to the two adjacent, this cell here, y prime z prime, y prime z. Y prime is not changing the only variable that is changing is z prime. Any two consecutive cells, they will have one variable that is changing. The same here, y prime z, yz. Z is fixed but what is changing is y, y prime. The same between these two columns here, if you look up. Yz, yz prime so z prime is changing. Then we look at this true table here. What we have here, we have x prime yz, x prime yz is this one is one. Then we have again xy prime z, xy prime z is this one is one. Then we have again xy prime z, :29 which is this one, is one. Then we have again x yz prime is this one. Then we have xyz is this one, is one. We can clearly see, I don't know if it's here. This block here, what is changing?. Y and z is one, even if it's x prime or x. X is not changing this value one so we can really rewrite this as yz. This is equivalent to yz. Again here, x is the same in all those four cells. Although y is changing, z is changing but it did affect the value here. Because x is not changing, we can only leave it, this as x and we rewrite all this function, as x. All this can be simplified to be x and all this can be simplified to be just yz. If I want to write this function, :07 find the truth table, it will give me the function f of xyz. Just found the truth table, it will give me x prime yz plus the second column will give me xy prime plus xy prime z prime plus x, the third one, x y prime plus xy prime z plus xy. :02 Is it prime for this one?. Plus xyz. :08 This is using the truth table, we can get this. :14 Now, this is still too much. They would give us an expression. What we do here is we do the Karnaugh map. I put here, let's say, let's put here x and lets put here x prime and I put here x and I put here y prime z prime and I put here y prime z. If you can see, I left y prime the same and I changed z. Two consecutive cells will change, only one will change. Again here, I'll do yz. Again, between this column and this column, z is the same. What is changing is y. Then between the other one, the last one I have is yz prime. Yeah, y is the same, and z is changing. Then I go back to my function, which is this one, x prime yz, where is x prime yz? x prime yz is this one. x prime yz one. Then I go to this xy prime z , xy prime z is this one. Then I go to this xy prime z, xy prime z is one. Then I go to this one, xyz prime, xyz prime is this one. Then I go to the last one. xyz is this one. Yeah, then I put the ones, and the rest here can be all the zeros that are left those three zeros. Now, I can group them. Yeah, I can group them. I can do this group here. I can see here yz is not changing in this column here, what is changing is x and x prime. So this can be equivalent to just yz. Then I can group again this all those consecutive ones here. It's always 1s for x. It doesn't matter if the value of y or y prime or z is changing, then this will be just equivalent to x. This will be equivalent to yz. My function now f of xy, :04 f of xy can be written as just x plus yz. A question. Yeah,. About constructing this table, would it matter if you chose either y or z in the horizontal and said, maybe x and z or y. No, I don't think it would matter. It wouldn't matter. What you need to know is any two consecutive cells, yes, they need to have only one viable that is changing. Right. Yes. The others are fixed. Okay. Yes. If you have that, you might get different shape. Yes. But it will give you the same result. Okay. Thank you. Yes. But what you need to catalog when you're writing those ones, you need to say y prime z. y prime is fixed between two consecutive cells where we always have one thing that is changing. That way when you group all the 1s, anything that is changing didn't affect you remove it from the expression. :39 Does this makes sense? Yes, that's correct. Thank you. Okay. All right. When grouping ones, we group only one or two or four. Yes. That's it right? Depending on what you've got, what I mean. You group the ones that are adjacent to each other. Okay if they are three, we cannot. Yes. As long when you group them, you see what variable is changing. Sometimes your group them and you might have only to group the first two, and the other two here. It depends what the variable that is changing. Then we can still simplify them if we see them that there's. Yes. Okay. Thank you. That's okay. So starting from this Boolean function, you can find the expression using the sum products. Then the sum product can really simplify the expression, as you have seen using the sum product I got this. By using the Karnaugh map, I actually go x plus yz. So the whole thing is simplified and it gives me less. :12 You saved a lot of money on love space and a lot of logic gates as well. The computation of this is faster than computing this. All right. :31 I think that's what today was about, just giving you a summary of what you need to know from this. There are some parts because you've already seen this. There's some part when I was going a bit faster. But what you need to know the application of Boolean algebra, operations of Boolean algebra. You need to know those logic gates and logic networks. You need to know if you have a network, you can build it's Boolean function. If you have a Boolean function, you can build a logic network for it. You also need to know how to simplify Boolean expressions. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 5.2 Applications Lesson 5.3 Extra resources Video: Video Webinar on Boolean algebra . Duration: 1 hour 26 minutes 1h 26m Reading: Reading Boolean algebra problem sheet . Duration: 10 minutes 10 min Reading: Reading Boolean algebra problem sheet solution . Duration: 10 minutes 10 min Lesson 5.4 Summative assessment Lesson 5.5 Midterm assessment
# Semaphores
Video•
. Duration: 5 minutes
5 min

URL: https://www.coursera.org/learn/uol-how-computers-work/lecture/QUUL8/semaphores

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key You now know about processes, which are a great way of seeming to run multiple things at the same time on a computer. But up to now, we've thought of each process as completely independent of all the others. They got their own memory areas, they don't interact. What one process is doing doesn't affect the others. But sometimes they do need to interact, or at least, they sometimes need to interact with the same resources. So what do I mean by resource? Well, different processes could be trying to access the same file or the same printer. In the case of threads which do share memory, they might be accessing the same bits of memory and things can get a little bit complicated. So if one process wants to access a resource, that's fine, it can do what it wants but the minute another process starts accessing it, there could be problems. If all they want to do is read from that resource, it's probably okay. But if either of them wants to write to the resource, or even worse, if both of them try to write to each other at the same time, there can be trouble. The second process might start reading data but the first process is writing to that data, so it's changing while it's being read, resulting in mistakes. Or if they both start writing, or better off, you can get complete nonsense because they'll start interleaving words and letters. Having simultaneous access can cause lots and lots problems, so what can we do? Well, we've seen this before when we talked about files. Files can be locked. So when the first process accesses the file, it locks it. So the second process can't access it. But how does locking work? Well, locking a result means setting a value of some bits of memory, probably literally one bit of memory. So a lock might be a value of 1 when it's locked and 0 when it's unlocked, but nonetheless, it is memory, which is a shared resource. So the problem is that both processes can access that lock. That lock itself is also a shared resource, that two processes can try to access it at the same time. Let's look in detail at what could happen. Remember that the processes are not actually accessing the resource at the same time. They're time-slicing, they're taking turns. So process one wants to write some data. It checks the lock, the lock is unlocked. Brilliant, it's now about to set the lock, except interrupt! And the second process comes in. And it also checks the lock, which is still unlocked. It can therefore write to the resource. It locks the resource and starts writing. But what happens when we switch back to the original process? It's already checked that the lock is unlocked. So it thinks it can write to the resource and starts doing so. But the second process has locked it, so we still have two processes writing to that resource at the same time. What's the solution? Well, there's a special instruction in hardware that first checks whether a lock is locked and sets the lock at exactly the same time as it checks, so that nothing can interrupt that interaction. This special kind of lock is a semaphore. And to make sure that this works, the instruction has to be implemented directly in the CPU. Great, so now we've solved all of the problems. No, we haven't, let's look at this again. So there's a process and it locks a resource for example an audio file, fine no problem. What if you have a second resource maybe a sound card and another process locks that resource? Fine, still no problem. We've got two processes each with their own resource. The problem comes when the first process also wants the second resource. It might want to play the file on the sound card, but it's locked. And the second process wants the first resource. It might want to record for the to the file but it's also locked. The first process is waiting for the second resources and can't proceed it won't unlock is resources until it can get access to resource 2. And the second place is waiting for the first resource. But likewise, it can't proceed and won't unlock its resource. So both processes are waiting for the other one to unlock their resource, which is never going to happen. This is something called deadlock. And it's one of the problems that you have to deal with when you're creating software that uses multiple processes and shares resources. What we've discussed in this video is just a little bit of the complexity you can get with what we call parallel software. Software where multiple processes are running at the same time, particularly when they share resources. This is quite an advanced field of computer science. It's a challenging way of programming, and something you might learn more about as you become a computer scientist. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 12.1 Inter-process Communication Video: Video Semaphores . Duration: 5 minutes 5 min Reading: Reading Handling competition among processes . Duration: 50 minutes 50 min Practice Assignment: Practice quiz – Five questions on inter-process communication . Duration: 30 minutes 30 min Discussion Prompt: Concurrency problems . Duration: 30 minutes 30 min Video: Video Mobile payments . Duration: 4 minutes 4 min Lesson 12.2 Summary
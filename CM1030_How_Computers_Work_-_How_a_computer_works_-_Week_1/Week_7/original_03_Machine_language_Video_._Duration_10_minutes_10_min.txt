# Machine language
Video•
. Duration: 10 minutes
10 min

URL: https://www.coursera.org/learn/uol-how-computers-work/lecture/arzaF/machine-language

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key Let's try to understand how a CPU works by executing instructions. So, what does an add instruction look like? Well, it looks like this. That's completely easy to understand, I think it explains everything, so end of lecture. Now, of course not, that's just a string of binary digits. How am I supposed to understand that? Well, like everything else at the low level of computer, it's just a pattern of bits. We heard earlier in the course how all the data we want to use on a computer has to be represented as bits. Well, so do our instructions. We can start to understand them a little bit better by breaking them down. The most important thing we need to know is the start of the instruction is something called an opcode. The abbreviation op stands for operation. There are many different operations the CPU could do. For example, adding, multiplying, subtracting, and a bunch of other things that I'll talk about in the next few slides. Each type of operation has a code, which is a bit passive. In this case, 0101, which stands for add. So, what is the rest of the instruction? What are all the other bit patterns? These are the operands. Any instruction will depend on various other data to do its job. So, if you're adding, you need to know which numbers you're adding together, and those numbers would make up the operand. Its very much like calling a function in a high level programming language like JavaScript. The opcode is a bit like the function name. The operand is a lot like the arguments of that function, the data you're passing into the function. So, we now know what the different bits of an instruction are, but to me, this code doesn't make much sense. I know that 0101 stands for add, but it still isn't easy to read. So, in future slides, I'm not going to use binary digits for opcodes. Instead, I'm going to give them names. So, this becomes add, which I hope you agree is easy to understand. I will also change the bit patterns of the operands into decimal numbers, which I at least think it clearer. Now, let's take a closer look at the instruction. Firstly, the opcode. This tells us that we're adding some stuff together, but what are we going to add together? We need to look at the operand. This part tells us one of the numbers that we're going to add. But it isn't actually the number itself, it's the number of a register. As we learned, a register is a little bit of memory on the CPU. Each register has a number. In this case, one. What this operand is telling us is that we want to add the number that's stored in register one. The next part tells us that we want to add that to the number that stored in register two. So the last teapots of the operand tell us which registers to get the data from to perform the addition. We're taking whatever value is in register one and adding it to the value that's in register two. , we have to put the result somewhere. The first part of the operand tells us which register to store the result in. In this case, register three. In a high level language like JavaScript, it looks like this. The three registers, R1, R2, and R3, work a bit like variables. They're essentially places to store data. We add together R1 and R2, and put the result in R3. So let's have a think about how this actually works on a CPU. Here is our little model of a CPU and memory. This instruction takes the value in register zero and the value in register three, it adds them together in the arithmetic logical unit and saves the result back to register five. This is a simple example of an arithmetic operation. So, that was quite a simple operation. Let's have a look at some of the other things you can do with instructions. Another important instruction is load. Not all instructions deal with mathematical calculations. A load instruction loads data from memory into registers. We want to take some data from memory at the memory location given by these last two numbers. Now, there aren't many registers, so you only need small numbers to tell you which register you want, but there's lots of memory. So, one number is not enough, you need a big number to give you the memory address. That's why the last two parts of the operand are combined to give you a memory address. The first part of the operand is the register we're going to put the data in. The load instruction, grab some data out of that memory location, and puts it into the register. It's an example of a data transfer operation, one that moves data from one part of a computer to another. Another data transfer operation is store, which does exactly the same thing in reverse. It grabs something out of the register and puts it in memory. These two operations together allow you to communicate with memory, and are essentially about transferring data between memory and registers, registers and memory. I now want to show you a slightly more complex instruction jump, which is an example of a control instruction. This is a really important instruction because it's central to how the control of a program works. Actually, it's a bit like an if statement. We use an if statement to control which parts of our program are executed. On the CPU, we don't have anything as complex as an if statement, but a jump is a simplified version. What it actually does is instead of always just moving on to the next instruction, it jumps to a different instructions somewhere else in memory. The thing that tells us which instruction we should be executing is the program counter. That's a register that holds the memory location of the next instruction. What a jump instruction does is put a different number in that program counter. Most of the time, often instruction is executed, the CPU just adds one to the program counter, so that it moves to the next instruction. But you can also put any value you want in the program counter. That is what the jump instruction does. It takes the last two parts of the operand and copies them into the program counter. Doing that means the CPU fetches an instruction from a different better memory. So, you're moving from one part of your code to another, and that is essentially how you control your code. What does the first part of the operand do? Well, there's a certain type of jump instruction called a conditional jump. You don't necessarily always want to jump and that's what this is for. For example, in an if statement, the program does one thing if the condition is true and another thing if it's not, so it's making a choice. If all you could do is just jump, you have no choice. Then, you couldn't really control how your program works. Therefore, you have to be able to make a choice, which is what a conditional jump does. In an if statement, that choice can be based on a very complex calculation. But on a CPU, things have to be a lot simpler. A conditional jump takes the value in the register given by the first operand, in this case, register five, and compares it to the value of register zero. It's always register zero, whatever the instruction is. If the values in the two registers are the same, it will jump to the new instruction. If they're not the same, it will just carry on and move to the next instruction in the sequence. So, this is a very simplified version of an if statement. By having a lot more instructions, you can build an if statement using this very simple jump instruction. So, these are some of the examples of the kinds of things that make up machine instructions, the most basic language of the computer, the language that is actually implemented in hardware. Any other programming language you use or any other software is made by combining together a whole load of these instructions. We have tools called compilers, which take a high level language like C, and convert it directly into machine instructions. Or we have other software called interpreters, that instead of converting code all at once, will convert a language like JavaScript into machine instructions as it's running. We need this software because the only thing that the CPU actually knows how to do is execute machine instructions. It doesn't understand JavaScript or C or Java or any other high level language. The instructions I've given here are just examples, they're not a real machine language, and each type of CPU, whether it's Intel or ARM, will have its own machine language, which will be much more complex on this. But this simple language is close enough to the real languages to give you an idea of what they can do, and we'll use it in the examples and exercises later in this topic. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 7.0 Introduction Lesson 7.1 Computer architecture Lesson 7.2 Machine language and execution Video: Video Machine language . Duration: 10 minutes 10 min Reading: Reading Machine language . Duration: 1 hour 1h Reading: Reading CPU simulation . Duration: 15 minutes 15 min Ungraded Plugin: CPU simulation . Duration: 1 hour 1h Practice Assignment: Practice quiz – Machine language . Duration: 30 minutes 30 min
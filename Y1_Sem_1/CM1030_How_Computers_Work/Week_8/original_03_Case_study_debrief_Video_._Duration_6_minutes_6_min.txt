# Case study debrief
Video•
. Duration: 6 minutes
6 min

URL: https://www.coursera.org/learn/uol-how-computers-work/lecture/ruHoI/case-study-debrief

## VIDEO TRANSCRIPT ## You may navigate through the transcript using tab. To save a note for a section of text press CTRL + S. To expand your selection you may use CTRL + arrow key. You may contract your selection using shift + CTRL + arrow key. For screen readers that are incompatible with using arrow keys for shortcuts, you can replace them with the H J K L keys. Some screen readers may require using CTRL in conjunction with the alt key As part of this topic, we've been trying to understand how code works and what it actually does in terms of the CPU. This is the code we've been looking at this week, and I'm going to take you through and make some points about what I think is happening behind the scenes. I just want to remind you again that if this was JavaScript, it would actually be much more complicated than what I'll describe, because there's lots of other things going on at the same time. However, for a very simple language like C, what I'm going to say is reasonably accurate. Okay, let's look at the first line. Well, here we're adding two numbers together. So, that's quite clearly an add instruction. We firstly have to remember that the instructions act on registers. The value one is probably going to be stored in a register, let's say register three. The same goes for the variable i. We need to get that variable, whatever its value, into a register say five. It might be that your variable is used so much in this bit of code that it's already stored in the register. But most variables need to be stored in memory, so it may need to be loaded in with a load instruction. Once the arithmetic logical unit has done the addition, it will save the results of the add back into a register. In this case, because it's using the variable i, it will probably store the result back into the same register five. Once it has been saved into a register, the variable will probably need to be stored back into memory. Now, that might happen immediately after the add instruction, or it might happen a little bit later once some of the other processing has happened. The next line is an if statement that would be implemented by conditional jump. We take the register that holds the value of variable i, and compare it with the value in register zero. To make this instruction work, we'd need to have put the value 100 in register zero. If the values are equal, we would jump to the code that says i equals zero. Otherwise, you would move to the next instruction which will be the here. This line is setting the value, variable i. It will be a move operation that copies a value into a register corresponding to y, and possibly a store statement to save it back to memory. This final line of code, calls a function called point. That means that it is executing some complex code behind the scenes, which we don't see in this code snippets. Functions are really useful as they allow us to write simple code, but make use of lots of functionality. How does a function work in terms of machine language? Well, a function means that we're going away and executing some different code before coming back to finish off this code. That means we need a jump instruction to go to the code that implements the function, and another jump function to come back. The values of i and 50 would have to be put into registers ready for the function to use them. Point is a drawing function. So, it involves drawing something to screen. That means sending data to a peripheral device, the graphics card, and ultimately the screen. This means doing some sort of store instruction to send data from registers to the graphics card. If the graphics card is memory mapped, it would simply be a standard store location, but the results end up in the graphics card rather than memory. Which bits of this code are fast and which are slow? The add instruction is likely to be pretty fast, because it's just happening on the CPU. Reading, writing, and manipulating from registers. The load and store instructions access memory so that will be slower. Maybe a bit less or if they're in the cache, but still cache accesses a lot slower than register access. Finally, when you're sending data to a peripheral like the graphics card, that's going to be the slowest of all. So, anything that involves drawing to a screen or taking keyboard input is going to really slow the program down quite a lot. Still, this is not anything that a human would notice, but you might find that if you're not careful with the way you code drawing functions, they can slow the program down. What about different examples of code? What would change? What different choices would result in different performance? We've just seen that having a lot of interaction with peripherals is likely to slow things down. So, we want to make as few of these as possible. In fact, the way modern graphics works, is that they tend to store up a lot of data that needs to be sent to the graphics card, and send it all together to make sure that you're not making too many slow stores. Another important effect is the amount we access memory. This program only uses a tiny amount of data, a single variable. This variable can easily be stored in a register and can stay there the entire time, which makes it fast. If we increase the number of variables to close to, or more than the number of registers, then some would have to be stored in memory, and move in an out of memory repeatedly slowing things down. This can be mitigated by the cache, but if the data is bigger than the cache or the program changes the data it uses a lot, like when you're streaming video, then the cache might not have the right data and we would need to go to memory. Jump instructions also go to memory because they fetch instructions from there. So, calling a lot of functions might slow things down particularly if the function itself takes a small amount of time, so the jump takes longer than the code itself. For this reason, many modern compilers will do something called inlining small functions. That means they don't use a jump. They just copy the entire function code into your standard code. This speeds things up for small functions though it can be inefficient for big ones. So, that's a bit of code that hopefully has helped you understand a bit more about how some of the code you may write will be implemented on CPU. As I've said before, there's a lot of complicated stuff going on in a program. What I've just run through is a big simplification of the process, but I hope it still helps you to have an idea in mind of how a CPU might be executing the code you write. ## END TRANSCRIPT ## ## ADDITIONAL PAGE CONTENT ## Lesson 8.1 Communicating with devices Lesson 8.2 Summary Peer-graded Assignment: How does code work? . Duration: 3 hours 3h Review Your Peers: How does code work? Video: Video Case study debrief . Duration: 6 minutes 6 min Discussion Prompt: What have you learned? . Duration: 10 minutes 10 min Graded Assignment: Summative quiz [001] – topic 4 Submitted Video: Video Summary . Duration: 1 minute 1 min
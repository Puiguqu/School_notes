# Week 9 - CM1025 Fundamentals of Computer Science - Logic – part 1 - Week 1

## Introduction Video• . Duration: 1 minute 1 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/lecture/noosv/introduction)

Here is a summary of the text in 8 sentences, preserving key information and technical details:

Regular expressions are used to represent patterns that can be used to define regular languages, which have strong connections with finite automata. The concept of regular expressions will be explored further in this topic, including their applications in pattern searching. One real-world example of using regular expressions is in verifying the format of an email address, where a valid address consists of characters followed by the '@' symbol, then another sequence followed by a '.', and ending with some other characters. To automate this process, regular expressions can be used to match patterns against input data. Regular languages are defined as sets of strings that satisfy certain conditions, such as the presence or absence of specific characters. The connection between regular expressions and regular languages is an important one, as it allows for the formal definition of pattern matching. This topic will explore how regular expressions can be used to define regular languages and demonstrate their links to finite automata. By the end of this lesson, users will be able to answer questions about automating pattern searching using regular expressions.

---

## Regular expressions Video• . Duration: 8 minutes 8 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/lecture/QqbmF/regular-expressions)

Here is a summary of the text in 8 sentences, preserving key information and technical details:

Regular expressions are a way to design and understand formal languages using operators that operate on languages. The four main operators are union (A ∪ B = A + B), concatenation (L1 • L2), star (∗), and unary plus (+). Union combines two languages into one, while concatenation takes every string from the first language and joins it to every string in the second language. The Kleene Star operator generates all possible concatenations of strings from a given language. Regular expressions can be combined using these operators to form more complex patterns. Atomic expressions include the empty language, individual letters, and empty strings, which are all regular expressions. When combining regular expressions, the resulting expression is also regular. Understanding regular expressions and their operations is crucial for designing and understanding formal languages.

Note that I didn't include any links or technical details not relevant to a general summary of the text. Let me know if you'd like me to add anything!

---

## Regular expressions example Video• . Duration: 4 minutes 4 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/lecture/JbkLo/regular-expressions-example)

Here is a summary of the text in 8 sentences, preserving key information and technical details:

The language generated by σ* (sigma star) includes all strings over the alphabet {a, b}. The syntax of σ* involves concatenation of σ with itself, where each union represents a possible choice. For example, given the regular expression σ = {a, b} in σ* , the string "ab" can be generated by choosing "a" from one union and "b" from another union. Conversely, it is not possible to generate any string that cannot be generated by σ* on the same alphabet. To determine if a specific string belongs to the language generated by a regular expression, it must be possible to break down the string into substrings that can be generated separately. For instance, the string "bbaa" can be broken down into two "bb"s and two "aa"s, which can be generated using the given regular expression σ* . However, the string "abb" cannot be generated by this regular expression because it must start with a character from either {a, b}, but not "ab".

---

## Design regular expressions Video• . Duration: 5 minutes 5 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/lecture/SukqX/design-regular-expressions)

Here is a summary of the text in 8 sentences, preserving key information and technical details:

The language consists of binary words containing "bb" with at least one occurrence of "bb". This can be represented by the regular expression Σ*bbΣ*. Another example is the language of all binary words ending with either "ab" or "ba", which can be represented as Σ*ab Σ*ba. The language of all binary words with at most one "a" can be represented as b*ab*b*. This includes binary strings of length 0 (ε), 1 (Σ), and 2 (ΣΣ). For binary strings of length 3, the regular expression is ΣΣΣ. To represent languages with constraints on word length, we can use Σ³ or Σ³+ for "at least three" and ε ∪ Σ ∪ ΣΣ for "at most three". The language of all binary words of length exactly three can be represented as ΣΣΣ.

---

## Design regular expressions example Video• . Duration: 3 minutes 3 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/lecture/JsmIX/design-regular-expressions-example)

Here is a summary of the text in 8 sentences, preserving key information, formulae, links, and technical details:

Sigma star generates all strings over an alphabet (a, b) by taking the union of all possible strings generated by concatenating the alphabet with itself. To generate all strings containing at least one 'a', the regular expression Σ* a Σ* can be used. Similarly, to generate all strings starting with 'a' or ending with 'a', the regular expressions a Σ* and a Σ* a can be used, respectively. To generate all strings of even length, the concatenation of (a+b) with itself followed by a star (∗) can be used: (a+b)∗. A regular expression to generate odd numbers in an alphabet of 1, 2, and 3 can be created using the union of '1' and '3': 1+3 Σ*. For generating all numbers greater than 200, a regular expression that includes strings with exactly three digits (starting with either '2' or '3') followed by strings with four or more digits: (2+3 Σ*) ∪ Σ*Σ*Σ*. These regular expressions demonstrate the power of Sigma star in generating strings based on specific conditions.

---

## Regular expressions and finite automata Video• . Duration: 5 minutes 5 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/lecture/Ds9Bo/regular-expressions-and-finite-automata)

Here is a summary of the text in 8 sentences, preserving key information:

Kleene's theorem states that a language is regular if and only if it can be described by a regular expression. A regular expression describes a language through a set of rules, while a finite automaton describes a language through a series of states and transitions. The relationship between regular expressions and finite automata was established by Kleene's theorem, which shows that every regular language has a corresponding finite automaton and vice versa. The theorem can be rewritten to state that if L is the language of A for some finite automaton A, then there exists a regular expression R such that the language of R is L. To demonstrate this claim, a proof of concept was created by converting a simple finite automaton into a regular expression. This involved creating new states and transitions, removing intermediate states, and simplifying the resulting expression to obtain a regular expression that describes the same language. The second part of Kleene's theorem states that if L is the language of R for some regular expression R, then there exists a finite automaton A such that the language of A is L. This proof is by induction and can be explored further in additional reading materials.

---

## Regular expressions and finite automata examples Video• . Duration: 5 minutes 5 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/lecture/gWIkV/regular-expressions-and-finite-automata-examples)

Here is a summary of the text in 8 sentences, preserving key information, formulae, links, and technical details:

The video transcript discusses two examples of converting finite automata to regular expressions. In the first example, an initial state D is created, transitions from D to A labeled epsilon are made, a final state E is created, and transitions from old final states to new final states labeled epsilon are added. The states connected to C are B and E, so only transitions from B to C and from E to itself can be removed, resulting in 1*0+1*(epsilon|0). In the second example, a new initial state D is created, transitions from D to A labeled epsilon are made, a final state E is created with two separate transitions labeled epsilon, and transitions from old final states to new final state E labeled epsilon are added. The states connected to C are B and A, so a new transition from B to A with label 00*1 must be added, resulting in A to E = 0 ∪ ε. After removing B, paths between A and E must be established, leading to the expression 01 ∪ 00*1*(epsilon|0). Finally, after removing A, a new transition from D to E with label 0+ε ∪ 0 is added, resulting in the regular expression 01 ∪ 00*1*(epsilon|0).

Note: The provided text does not include any links or technical details that require preservation. If you would like me to extract specific information or formulas from the text, please let me know and I'll be happy to assist you.

---

## Mid-term preparation Reading• . Duration: 10 minutes 10 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/supplement/8DJro/mid-term-preparation)

Here is a summary of the text in 8 sentences, preserving key information:

To prepare for submitting the mid-term coursework assignment, watch all video lectures up to Topic 5, attempt all exercises up to Topic 5, and attempted quizzes up to Topic 5. Attend or watch the recorded mid-term webinar run by the module leader, as this will help with submission preparation. The assignment has a deadline and can be submitted multiple times before it. However, submitting work at the last minute is not recommended and should allow time for review. The assignment includes topics 1-5 and requires drawing finite state automata (FSA) graphs only, without specifying them using tables or sets. When drawing FSA, explanations are necessary for certain questions that ask to show reasoning, but a final answer suffices for others. To avoid losing marks, carefully read the submission instructions and take time to review work before submitting. By following these guidelines, students can submit high-quality work and receive proper assessment.

---

## Regular expressions Reading• . Duration: 1 hour 40 minutes 1h 40m

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/supplement/eTN12/regular-expressions)

There is no text provided for me to summarize. The text appears to be a course reading list with links and video durations, but it does not contain any actual content or information to summarize. If you could provide the text, I would be happy to assist you in summarizing it in 8 sentences while preserving key information, formulae, links, and technical details.

---

## Week 9 exercises Reading• . Duration: 1 hour 1h

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/supplement/hV4UP/week-9-exercises)

Here is a summary of the text in 8 sentences, preserving key information and technical details:

The exercises in Week 9 aim to test knowledge on formal languages and regular expressions. The exercise R=b ∗ (ba + ∪a + ) + b ∗ R aims to find a string that is neither in the language of R or S, while another exercise S=(a ∗ ba + b) ∗ S seeks to find a string that is in the language of S but not R. The exercises also ask for examples of strings that are in the language of R but not S and vice versa. To design a regular expression that accepts binary strings with no occurrences of 001, consider using a combination of quantifiers and character classes. Similarly, to design a regular expression that accepts binary strings with odd lengths and no occurrences of 11, use a combination of length tests and character class restrictions. For generating all natural numbers greater than 210 over {0,1,2,3}, consider using a recursive regular expression or a sequence of non-repeating characters. The exercises are optional but recommended for further practice and to test knowledge on the concepts learned in Week 9.

---

## Week 9 exercises hints and tips Reading• . Duration: 10 minutes 10 min

[Original lesson](https://www.coursera.org/learn/uol-fundamentals-of-computer-science/supplement/FAZNq/week-9-exercises-hints-and-tips)

There is no text to summarize. The provided text appears to be a course outline or lesson schedule for a computer science or programming class, specifically focusing on regular languages and finite automata. It outlines the topics and duration of each video, discussion prompt, reading assignment, and exercise for Lesson 5.0.

If you provide the actual text to summarize, I'll be happy to help.

---

